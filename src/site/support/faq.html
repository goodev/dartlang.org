---
layout: default
title: "FAQ"
rel:
  author: eli-brandt
has-permalinks: true
---

<h1>常见问题解答 (FAQ)</h1>
<em>最初由 Eli Brandt 收集整理<br>
版本 0.03, 2012 12月</em>

<p>
  这里解答了很多我们曾经被问及的有关Dart的问题。由于我们在1.0版本正式发布之前，只将Dart作为一个
  早期的技术预览版发布。因此前期一些重要的问题依然保留下来。我们希望在未来的工作和实验中处理他们。
  无论是在谷歌内部还是外部。
</p>

<section id="contents">

<h3>目录</h3>
<ol id="faq-toc" class="toc">
  <li><a href="#strategy" class="faq-topic">策略</a>
  <ol>
    <li><a href="#why-dart">为什么用 Dart?</a></li>
    <li><a href="#why-fix-the-language">Dart语言是否是我们需要的用来弥补目前WEB开发的不足？</a></li>
    <li><a href="#does-dart-divert-effort">Dart 能否替代基于 JavaScript 的 WEB 开发？</a></li>
    <li><a href="#will-dart-be-standardized">谷歌是否计划把 Dart 作为一门标准体系？</a></li>
    <li><a href="#how-will-dart-take-input">到此，你们将怎么加强 Dart 的更新</a></li>
    <li><a href="#why-not-designed-by-standards-body">为什么谷歌不在一开始就将 Dart 作为一个开放的标准发布？</a></li>
    <li><a href="#future-for-GWT"> GWT 的未来?</a></li>
    <li><a href="#why-not-multi-language-VM">谷歌为什么不开发一个包含 Dart 的多语言字节码虚拟机目标平台？</a></li>
  </ol> </li>

  <li><a href="#language" class="faq-topic">语言</a>
  <ol>
    <li><a href="#compare-to-javascript">Dart 跟 JavaScript 很像么?</a></li>
    <li><a href="#compare-to-java">Dart 跟 Java 的区别</a></li>
    <li><a href="#compare-to-closure">Dart 的语法结构与比 JavaScript 有哪些优势？</a></li>
    <li><a href="#compare-to-coffeescript">Dart 与 CoffeeScript 比较,优势在哪里？</a></li>
    <li><a href="#typescript">谷歌是怎样看待 TypeScript 的？</a></li>
    <li><a href="#compare-to-go">Dart 与 Go 会有联系么？</a></li>
    <li><a href="#compare-to-everything-else">为什么 Dart 不像 Haskell / Smalltalk / Python / Scala / 等其他语言？</a></li>
    <li><a href="#earth-shattering-syntactic-kaboom">为什么 Dart 的语法不做的更令人期待呢？</a></li>
    <li><a href="#is-it-a-dynamic-language">如果没有 eval() 方法或者不能在运行时给变量赋值, Dart 还能算是动态语言么？</a></li>
    <li><a href="#can-add-reflection">Dart 会增加"反射"么？</a></li>
    <li><a href="#can-add-everything">Dart 会添加数组、模式匹配、非空类型、局部变量、可选的分号等元素？</a></li>
  </ol> </li>

  <li><a href="#types" class="faq-topic">类型</a>
  <ol>
    <li><a href="#type-inference">Dart 有类型推断么？</a></li>
    <li><a href="#why-types-optional">为什么类型注释是可选的？</a></li>
    <li><a href="#why-types-unsound">为什么类型系统设计的不健全？</a></li>
    <li><a href="#sound-types-for-performance">不需要生命类型信息来提升性能么?</a></li>
    <li><a href="#types-why-no-runtime-effect">为什么类型注释在运行时是无的？</a></li>
    <li><a href="#why-covariant-generics">为什么泛型是协变的？</a></li>
  </ol> </li>

  <li><a href="#tools" class="faq-topic">用法与工具</a>
  <ol>
    <li><a href="#should-i-use-dart-yet">我应该用 Dart 开发WEB应用程序么？</a></li>
    <li><a href="#interop-with-js-libs">Dart 代码与 JavaScript 库是如何交互操作的？</a></li>
    <li><a href="#js-codebase-integration">我前期开发了大量的 JavaScript 代码。怎样才能迁移到 Dart ？</a></li>
    <li><a href="#porting-from-GWT">I have a large application written in GWT. How do I port it to Dart?我有一个在 GWT 环境中编写的大型应用程序，怎样才能与 Dart 对接？</a></li>
    <li><a href="#what-browsers-supported">像 JavaScript 编译目标那样，哪些浏览器会被 Dart 支持？</a></li>
    <li><a href="#what-browsers-have-dart">截至目前哪些浏览器支持 Dart ？</a></li>
    <li><a href="#hello-world-js-size">为什么生成的输出“Hello world"的 JavaScript 代码那么大？</a></li>
    <li><a href="#debugging-output-js">Dart 代码被编译成 JavaScript 代码后，我该怎么样调试？</a></li>
    <li><a href="#what-input-compiles">任何 Dart 代码都可以编译成 JavaScript 代码么，有没有什么限制？</a></li>
    <li><a href="#json-support">Dart 支持 JSON 么？</a></li>
    <li><a href="#server-support">Dart 能在服务端运行么？</a></li>
  </ol> </li>

  <li><a href="#acknowledgments" class="faq-topic">鸣谢</a></li>
</ol>
</section> <!-- /#contents -->

{% comment %}
<!--
TODO: do we have a standard trick to add some scrollable whitespace at the bottom so people can click on the bottom TOC entries (like #server-support) and go to the right place? 

ANSWER: no. :( It's a common problem but not one I'd thought about fixing. If we add space above the footer, people won't see the footer. If we add space below, it'll just look weird... but maybe that'd be OK. -->
{% endcomment %}

<section id="strategy">
<h2>Strategy</h2>

<h3 id="why-dart">问题：为什么选择 Dart ？</h3>

<p>在谷歌我们已经写出了很多优秀的WEB应用程序，我们通过各种方法努力改进其开发过程，但不尽如人意，我们发现缺少引入一门新的语言。现在时机到了。我们设计 Dart 是为了编写用于需要高的运行表现及适合最新应用开发的开发工具更容易。</p>

<h3 id="why-fix-the-language">问题：Dart语言能否弥补目前WEB开发不足？</h3>

<p>我们希望能够<a href="http://hyperboleandahalf.blogspot.com/2010/06/this-is-why-ill-never-be-adult.html">弥补所有的不足</a>。这就是 Dart 语言以及 Dart 整个项目的目标。Dart <em>项目</em>认为WEB开发语言应该有所改变，但是同时我们也希望能够<a href="/articles/improving-the-dom/">提升DOM</a>和其他的类库以及改善目前我们正在使用的开发工具。</p>

<p>同时，谷歌也认为 JavaScript <em>能</em>进一步被改进，并且积极的投入到这份工作中来。谷歌希望 WEB 开发变得更棒，如果这是由 JavaScript 带来的，我们同样会非常高兴。</p>

<h3 id="does-dart-divert-effort">问题：Dart 会转移那些以 JavaScript 为基础的WEB开发团体的工作么？</h3>

<p>如果人们喜欢 Dart 并且使用它，从某一方面来看，是的，但是任何一种对现有 WEB 开发的改进不都是这样么？完全重新开始或者100%兼容都不可取，所以人们一般旧的和新的一起用。你可以这样看：谷歌重在做有意义的尝试无论是基于 Dart 还是 JavaScript，选择发展中的 Dart同时继续广泛的使用 JavaScript 及其工具，实现，并且发展语言。我们同时都在做，因为我们认为 Dart 值得这么做。</p>

<p>有很多语言用于 WEB 服务器开发：Python 转移了 Perl 的工作么， Java 取代了 C++ 么？再次，从某一方面来看，是的，但是人们通常考虑健康的环境，多语言好于我们只使用单门语言开发，多语言允许快速转换，这已经通过一种标准的过程取得了效果。此外，每种语言都有其自己的存在价值：Groovy 亦不是与 C++直接竞争。人们面对不同工程权衡，选择不同的语言来应对。最后，我们希望客户端开发者们也可以有这种灵活性。</p>

<h3 id="will-dart-be-standardized">问题：谷歌打算把 Dart 语言交给标准团体控制么？</h3>

<p>是的，我们希望那样。一旦 Dart 语言发展到一定程度并且被大众接受，我们期待标准化过程将作为下一步目标。</p>

<h3 id="how-will-dart-take-input">问题：到这里，你们将怎样推进 Dart 的发展？</h3>

<p>我们计划像控制 V8 项目那样控制 Dart。我们将聆听反馈和问题，并且我们将检查外界 Dart 贡献者的修改。 一个有着很好痕迹记录的贡献者将会为 Dart 仓库提交确认。谷歌工程师也将会在公共仓库中工作，进行可见的修改。</p>

<h3 id="why-not-designed-by-standards-body">问题：谷歌为什么不一开始就将 Dart 作为一个开放标准公布？</h3>

<p>我们通过一般途径取得开放标准的程序语言：某人创建一个清晰的初版，人们尝试它，然后我们使其标准化。开放标准 WEB 平台以这种方式整合小的改进，经其他人的尝试后标准化就实现了：canvas就是一个例子。我们知道这种方式增加了大众参与，但是我们认为这种方式只在某些时候有用，特别的，作为一门编程语言，其由开放团队设计是有风险的。</p>

<p>Haskell是近期成功的被开放社区设计的变成语言，始于1990年。最广泛使用的是COBOL，从Ada演变而来。这不是一个程序语言设计的普通方式。在目前主要的编程语言中，只有六个（数字存在争议）是通过这种方式设计的（其中之一是 ALGOL-68)。</p>

<h3 id="future-for-GWT">Q. What's the future for GWT?</h3>

<p>Bruce Johnson <a href="http://googlewebtoolkit.blogspot.com/2011/11/gwt-and-dart.html">posted on the GWT blog</a> (with further comments <a href="https://plus.google.com/117487419861992917007/posts/6YWpsHpqMqZ">on Plus</a>): "Dart and GWT both share the goal of enabling structured web programming. In fact, many of the same engineers who brought you GWT are working on Dart. We view Dart as an ambitious evolution of GWT's mission to make web apps better for end users, and we're optimistic about its potential. As Dart evolves and becomes ready for prime time, we anticipate working closely with the GWT developer community to explore Dart."</p>

<p>"Meanwhile, rest assured that GWT will continue to be a productive and reliable way to build the most ambitious web apps&mdash;and even games like Angry Birds. Key projects within Google rely on GWT every day, and we plan to continue improving (and open-sourcing) GWT based on their real-world needs."</p>

<p>Watch our Google I/O 2012 talk <a href="http://www.youtube.com/watch?v=VOf27ez_Hvg">The History and Future of Google Web Toolkit</a> to learn more.

<h3 id="why-not-multi-language-VM">Q. Why didn't Google build a bytecode VM targetable by multiple languages including Dart?</h3>

<p>Each approach has advantages and disadvantages, but we feel that in the context of Dart it made sense to build a language-specific VM for the following reasons:</p>
<ul>
<li>Google already works on a multi-language bytecode: <a href="https://developers.google.com/native-client/overview#distributing-an-application">LLVM bitcode in PNaCl</a>.</li>
<li>Even if a bytecode VM is specialized for Dart, a language VM will be simpler and faster because it can work under stronger assumptions&mdash;for instance, a structured control flow.  These assumptions make the implementation cleaner and optimizations easier.</li>
<li>A general-purpose bytecode VM would be even larger and slower, as it generalizes assumptions and adds functionality that for Dart is dead code: for example, multithreading with a shared heap.</li>
<li>No bytecode VM is truly general-purpose; they all make assumptions that privilege some class of languages.  A language VM leaves more room to improve the VM and make deep changes to optimization of the language. Some Dart engineers wrote <a href="/articles/why-not-bytecode/">an article</a> talking about the VM question in more detail.</li>
</ul>

</section> <!-- /#strategy -->

<section id="language">
<h2>Language</h2>

<h3 id="compare-to-javascript">Q. Isn't Dart a lot like JavaScript?</h3>

<p>Yes and no.  The Dart project thinks that JavaScript can use some changes for more productive software engineering, smarter editors and development environments, and web apps that are as beautiful and pleasing as the best client apps can be.  On the other hand, we don't think everything needs to change, and why change what isn't broken?</p>

<p>Dart, like JavaScript, is a dynamically typed language.  It adds optional compile-time type annotations to help you catch errors earlier.  It takes out a few features of JavaScript, such as prototypes and the global object: this should streamline the VM, enable faster execution, and make it easier to do code completion and refactoring.  And Dart adds some goodies.  To name a few:</p>
<ul>
<li>User-defined operator methods.  We like the lightweight, readable code these give for <a href="/articles/improving-the-dom/">our DOM interface</a>.</li>
<li>Lightweight syntax for anonymous functions.  You use them a lot in web programming; now they look great.  And they come with correct binding of <code>this</code> and full block-level lexical scoping, no gotchas.</li>
</ul>

<p>
Dart aims to be like JavaScript, but faster, more regular, and more scalable to large programs.
</p>

<h3 id="compare-to-java">Q. Isn't Dart a lot like Java?</h3>

<p>Well, Java is statically typed, and Dart is dynamically typed.  Dart has optional static type annotations, where in Java they are required.  To us these are big differences in the nature of the two languages.  But Dart is a curly-brace language, and it shares some keywords with Java, such as <code>extends</code> and <code>final</code>, so we can see why people make the comparison.  Honestly, we like having a straightforward and familiar syntax that's easy to pick up, even if that means it's less exciting.</p>

<h3 id="compare-to-closure">Q. How does Dart compare with using the Closure compiler on JavaScript?</h3>

<p>The idea of optional type annotations is similar.  Dart's are nicer syntactically.</p>

<p>Compare the following Closure compiler code:</p>

{% prettify dart %}
// Closure compiler code

/**
 * @param {String} name
 * @return {String}
 */
makeGreeting = function(name) {
  /** @type {String} */
  var greeting = 'hello ' + name;
  return greeting;
}
{% endprettify %}

<p>With the following Dart code:</p>

{% prettify dart %}
// Dart code

String MakeGreeting(String name) {
  String greeting = 'hello $name';
  return greeting;
}
{% endprettify %}

<p>If you are using Closure and can switch to Dart, you will probably enjoy the change.</p>

<h3 id="compare-to-coffeescript">Q. How does Dart compare with CoffeeScript?</h3>

<p>Both Dart and CoffeeScript are inspired by JavaScript, and both can be translated back to it.  They make different choices, particularly in the flavor of their syntax.  As a language we think it's fair to say that Dart differs semantically from JavaScript more than CoffeeScript does; that may result in a less line-for-line translation, but we believe Dart-generated JavaScript can have excellent size and speed.</p>

<p>If you like CoffeeScript for its more structured feel than raw JavaScript, you may like Dart's optional static type annotations.</p>

<h3 id="typescript">Q. What does Google think of TypeScript?</h3>

<p>TypeScript and Dart have similar goals; they make building large-scale web applications easier. However, their approaches are fairly different. TypeScript maintains backwards compatability with JavaScript, whereas Dart purposely made a break from certain parts of JavaScript’s syntax and semantics in order to eradicate large classes of bugs and to improve performace. The web has suffered from too little choice for too long, and we think that both Dart and TypeScript are pointing to a brighter future for web developers! You can read a <a href="http://news.dartlang.org/2012/10/the-dart-team-welcomes-typescript.html">more complete response</a> on our blog.</p>

<h3 id="compare-to-go">Q. How does Dart relate to Go?</h3>

<p>Dart and Go are both language projects started at Google, but they are independent and have different goals.  As a result, they make different choices, and the languages have very different natures, even while we all try to learn from each others' work.</p>

<h3 id="compare-to-everything-else">Q. Why isn't Dart more like Haskell / Smalltalk / Python / Scala / other language?</h3>

<p>Various reasons, depending on the language being asked about.</p>

<p>For languages that are quite different from JavaScript: it's important for Dart to compile to efficient JavaScript.  Our experience in GWT is that if the source language is too different from JavaScript, it creates some cases where complex output code is needed to emulate the source language's behavior.  This can cause performance to vary in ways that are not transparent to the programmer.</p>

<p>For languages that are less mainstream: we expect that modeling Dart on these would, on the whole, hurt our adoption.  Our team includes fans of these languages, and if we thought Dart could take up our favorite cool language features and push them to widespread adoption we might be tempted, but really we think we've got our hands full introducing a new language at all.</p>

<p>For languages that are "more dynamic" than Dart: Dart deliberately trades off some of this arbitrary runtime modification for the goal of better performance and tools.</p>

<h3 id="earth-shattering-syntactic-kaboom">Q. Why isn't Dart syntax more exciting?</h3>

<p>We did throw in some nice syntactic features such as <code>this.</code> constructor args, but we'd agree that Dart chooses familiarity over excitement.  One team member's personal testimonial: "I wish it had a little more razzle dazzle but I can't deny that literally on my first day of writing Dart code, I was productive in it."</p>

<h3 id="is-it-a-dynamic-language">Q. Is it really a dynamic language if it doesn't have eval() or adding fields to a value at run time?</h3>

<p>Dart as initially released didn't have anything like these, but future versions of Dart will look at adding dynamic features of this sort.  The feature set won't match up exactly with the features in your question, but we hope to serve very much the same purposes.  When we see what gets added, then everyone can decide how they classify the language.</p>

<p>What's important to us is that what you want to do with a dynamic language, you can do with Dart and not feel cramped.  You should be able to design your system without interference from static rules, and to modify the live system during development and sometimes at run time.</p>

<p>So, for example, Dart isn't likely to support evaluating a string as code in the current context, but it may support loading that code dynamically into a new isolate.  Dart isn't likely to support adding fields to a value, but it may (through a mirror system) support adding fields to a class, and you can effectively add methods using <code>noSuchMethod()</code>.  Using these features will have a runtime cost; it's important to us to minimize the cost for programs that don't use them.</p>

<p>This area is still under development, so we welcome your thoughts on what you need from runtime dynamism.</p>

<h3 id="can-add-reflection">Q. Can Dart add reflection?</h3>

<p>We are currently in the process of adding reflection support using the <a href="/articles/reflection-with-mirrors/">mirrors API</a>.</p>

<h3 id="can-add-everything">Q. Can Dart add tuples, pattern matching, non-nullable types, partial evaluation, optional semicolons, ...?</h3>

<p>The language is not finished yet.  It might be able to include your feature, although it can't include everything.  Some features don't fit the basic nature of the language, and some don't play well with other features.  Simplicity is the single most important gift we all can give to future programmers.</p>

<p>Please look at the <a href="http://code.google.com/p/dart/issues/list">list of Dart issues</a> to see if your request is already there, and add a new issue if not.  Make a thoughtful argument for your feature.  Sample code with and without your feature is good evidence; a sizeable codebase that shows the need is even better evidence.</p>

<p>Please don't be surprised if the Dart designers say "no" by default, especially for now.  It's far more painful to remove a language feature than to add it, so Dart is likely to add the most obvious features first, and then revisit the next tier later.  And there simply are more possible language features in the world that can fit into any single language without making a total hash of it.   But we do very much appreciate suggestions and evidence.  We hope you'll see our appreciation through careful design choices and fair communication about them.</p>
</section> <!-- /#language -->

<section id="types">
<h2>Types</h2>

<h3 id="type-inference">Q. Does Dart have type inference?</h3>

<p>Type inferencing is not something specified by the language specification, but it is something that implementations are free to do. It's important to remember that Dart has a dynamic type system, so type inferencing doesn't play the same role as it does in languages such as Haskell. However, Dart Editor does do some type inferencing, such as when you use var for local variables. We expect that the Dart VM and dart2js will use type inferencing when it's useful for performance or for other reasons.</p>

<h3 id="why-types-optional">Q. Why are type annotations optional?</h3>

<p>We want to maintain the feel of a dynamically typed language, which is familiar to web developers. Mandatory types don't fit with that goal.</p>

<h3 id="why-types-unsound">Q. Why is the type system designed to be unsound?</h3>

<p>Rather than using a full, static type system, Dart has a dynamic type system with optional static type annotations. Our main goals for the types are to support tooling and documentation. We want to build a pragmatic tool that helps web programmers without getting in their way.  In particular, we want our static warnings to be optimistic rather than to complain about dynamically typed code that may be valid and correctly written, such as "downcast" assignments.  Because Dart <i>execution</i> is always type-safe, we can let some unsound cases get through the static warnings and be caught at run time instead.</p>

<p>Typical object-oriented languages let you downcast, which also introduces unsoundness into the type system and may result in a runtime type error.  In Dart, we choose to allow downcasts without a syntax to mark them.</p>

<h3 id="sound-types-for-performance">Q. But don't you need sound typing information to get high performance?</h3>

<p>Sound types can help with performance but aren't essential. What we need are uniform, simple semantics.</p>

<h3 id="types-why-no-runtime-effect">Q. Why do type annotations have no effect on the runtime behavior?</h3>

<p>If type annotations affect the runtime, programs will change their behavior as programmers add type information, even though the logic remains unchanged. The normal mode of development is to gradually add types for documentation and validation, and if that changes what the program does, programmers have no stable foundation to work on. This is especially true given that types could be inaccurate.</p>

<p>In addition, this policy helps us and others add additional type-checking tools that implement different policies without unforeseen interactions with the runtime.</p>

<h3 id="why-covariant-generics">Q. Why are generics covariant?</h3>

<p>Covariant generics fit a common intuition that programmers have, and very often this intuition is correct, such as in the common "read-only" use of a generic.  Although this intuition isn't always correct, Dart doesn't need it to be.  Dart has already chosen optimistic static checking, so why not continue down that path and allow covariant uses of generics to pass static type checking?</p>

<p>Where covariant generics are too optimistic, Dart's type-safe execution allows the static warnings to be optimistic without being dangerous.  Although covariance can be pessimistic too, we think it will be rare that people run into that, and and there's a simple workaround for any pessimism.</p>

<p>We are familiar with a variety of ways that languages try to mark or infer variance.  We don't think any of them are suitable for Dart, where we want type annotations to be optional and unobtrusive: it wouldn't fit to <em>require</em> marking, and we feel that variance inference systems add too much complexity for their benefit in Dart.</p>

<p>Again, we're trying to be pragmatic, and we think the outcome is reasonable.</p>
</section> <!-- /#types -->

<section id="tools">
<h2>Usage and tools</h2>

<h3 id="should-i-use-dart-yet">Q. Should I write my web app in Dart?</h3>

<p>We'd love for you to try Dart and give us feedback.  If your web app is something that needs to be ultra stable, we recommend waiting until Dart is more mature.  However, if you're willing to follow our <a href="http://news.dartlang.org/">blog</a> and update your code in response to breaking changes we occasionally make, you may find that Dart is a really exciting community to be a part of!</p>

<h3 id="interop-with-js-libs">Q. How does Dart code interoperate with JavaScript libraries?</h3>

<p>Although Dart and JavaScript are completely separate languages with potentially separate VMs, they can interoperate. See <a href="/articles/js-dart-interop/">this article</a> to learn how.</p>

<h3 id="js-codebase-integration">Q. I have a large JavaScript codebase.  How would I migrate it to Dart?</h3>

<p>Try migrating one major feature at a time, and use the <a href="/articles/js-dart-interop/">JavaScript interoperability library</a> only when necessary.</p>

<h3 id="porting-from-GWT">Q. I have a large application written in GWT. How do I port it to Dart?</h3>

<p>Java and Dart are syntactically similar, so this might be easier than you think. You can rely on Dart Editor to flag any syntax problems. Alternatively, you may consider porting one feature at a time to Dart and using the <a href="/articles/js-dart-interop/">JavaScript interoperability library</a> as the common middle ground. Be sure to watch our Google I/O 2012 talk <a href="http://www.youtube.com/watch?v=EvACKPBo_R8">Migrating Code from GWT to Dart</a>, but keep in mind that it predates our JavaScript interoperability library.</p>

<h3 id="what-browsers-supported">Q. What browsers do you support as JavaScript compilation targets?</h3>

We're currently aiming to support the following browsers:
<ul>
<li>Internet Explorer, versions 9 and 10.</li>
<li>Firefox, latest version.</li>
<li>Chrome, latest version.</li>
<li>Safari for desktop, version 6.</li>
</ul>

<h3 id="what-browsers-have-dart">Q. What browsers support Dart now?</h3>

<p>As of December 2012, no production browsers can execute Dart code unless it's first compiled to JavaScript. However, the <a href="/tools/editor/">Dart Editor</a> ships with a version of Chromium (called Dartium) that has the Dart VM integrated into it. Dartium not only executes Dart code natively, but it also has really good interoperability with Dart Editor so that you can debug your Dart applications directly from within Dart Editor.</p>

<h3 id="hello-world-js-size">Q. Why was the JavaScript output for "Hello world" so big?</h3>

<p>Dart was young. At the launch of Dart, our initial goal was to generate functional JavaScript from Dart code.</p>

<p>Since the initial launch, we've created an improved compiler, dart2js, written in Dart. This compiler aims to be compliant with the language specification, and will continue to be optimized for performance. The dart2js compiler generates significantly smaller JavaScript output than the launch version of dartc (the original Dart-to-JavaScript compiler).</p>

<h3 id="debugging-output-js">Q. How do I debug Dart code after it's been compiled to JavaScript?</h3>

<p>dart2js now generates <a href="http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/">source maps</a>, so you can debug Dart code in browsers that don't support the Dart VM. However, even in rare cases where you must inspect the raw JavaScript, it's fairly debuggable using the browser's normal JavaScript development tools.</p>

<h3 id="what-input-compiles">Q. Will any valid Dart code compile to JavaScript, or are there limitations?</h3>

<p>Yes.  We intend for any valid Dart code to compile to JavaScript.  Of course, there are some libraries that will only run on the server because they don't make sense in a browser context.</p>

<h3 id="json-support">Q. Does Dart support JSON?</h3>

<p>Yes.  See the <a href="http://api.dartlang.org/docs/bleeding_edge/dart_json/JSON.html">JSON</a> class in the standard library.</p>

<h3 id="server-support">Q. Can Dart run on the server?</h3>

<p>Yes.  The dart:io library is aimed at server-side code that runs on the standalone Dart VM. dart:io uses an asynchronous programming model inspired by node.js, EventMachine, and Twisted. See <a href="/articles/io/">An Introduction to the dart:io Library</a> to learn more.</p>
</section> <!-- /#tools -->

<section id="acknowledgements">
<h2>Acknowledgments</h2>

<p>Thanks to users who asked questions, and to many Googlers who contributed questions, answers, and improvements: Mukesh Agrawal, Lars Bak, Adam Barth, Shannon -jj Behrens, Gilad Bracha, Paul Brauner, David Carlson, Patrick Doyle, Matthias Ernst, Nicolas Geoffray, Dan Grove, William Hesse, Bruce Johnson, Seth Ladd, Patrick Linehan, Florian Loitsch, John Messerly, Srdjan Mitrovic, Anton Muhin, Bob Nystrom, Jack Palevich, David Rochberg, Matt Shulman, Joel Webber, and Brian Wilkerson.</p>

</section>
