<!DOCTYPE html>
<html lang="en" itemscope itemtype="http://schema.org/Product" xmlns:wb="http://open.weibo.com/wb">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  
  <title>Dart 习惯用法 | Dart: 用于创建结构化的web应用</title>
  <meta property="wb:webmaster" content="a984f6440858ee44" />
  <meta property="twitter:account_id" content="376585411" />
  <meta itemprop="name" content="Dart 习惯用法 | Dart: 用于创建结构化的web应用">
  
  <meta itemprop="image" content="https://www.dartlang.org/imgs/dart-logo-wordmark-1200w.png">
  
  <meta itemprop="description" content="学习如何编写看起来像 Dart 的代码。">


  <link rel='stylesheet' type='text/css' href='/css/bootstrap.min.css'>
<link rel='stylesheet' type='text/css' href='/css/dart-style.css'>
<link rel='stylesheet' type='text/css' href='/css/prettify.css'>
<link rel='stylesheet' type='text/css' href='/css/font-awesome.min.css'>

  
    <link href="//fonts.googleapis.com/css?family=Montserrat:400,700|Roboto:300,400" rel="stylesheet">

	
	<link rel="author" href="/authors/bob-nystrom.html">
	
	<link rel="alternate" type="application/atom+xml" href="http://dartnews.sinaapp.com/?feed=atom" title="Atom feed">
  <!-- 
  <link href="https://plus.google.com/109866369054280216564" rel="publisher">
  -->
  <link href="http://weibo.com/cndart" rel="publisher">

  <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!--[if lt IE 9]>
    <script src="js/html5shiv.js"></script>
    <script src="js/respond.min.js"></script>
  <![endif]-->

  <!-- 
<script type="text/javascript">

  //var _gaq = _gaq || [];
 // _gaq.push(['_setAccount', 'UA-26406144-4']);
  //_gaq.push(['_setDomainName', 'dartlang.org']);
  //_gaq.push(['_setSiteSpeedSampleRate', 50]);
  //_gaq.push(['_trackPageview']);

 // (function() {
   // var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
   // ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
   // var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
 // })();

</script>
-->


  <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
</head>
<body onload="prettyPrint()">
    <div class="navbar navbar-fixed-top navbar-inverse" role="navigation">
      <div class="container">
        
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="/"><i class="sprite-icon-dart-logo"></i></a>
        </div>

        <div class="collapse navbar-collapse">
          <ul class="nav navbar-nav">
           <li class="dropdown">
              <a href="/codelabs/darrrt/" title="Learn Dart in this short code lab.">
                                                       入门
              </a>
            </li>
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">
                                                文档
              </a>
              <ul class="dropdown-menu">
                <i class="sprite-icon-dd-tip"></i>
                <li><a href="/docs/tutorials/">教程</a></li>
                <li class="divider"></li>
                 
                <li><a href="/docs/">开发者指南</a></li>
                <li><a href="http://api.dartlang.org">API 参考</a></li>
                <li><a href="/docs/spec/">语言规范</a></li>

                <li class="divider"></li>
                <li><a href="/docs/dart-up-and-running/">Dart: Up and Running</a></li>
                <li><a href="/books/">更多图书</a></li>

                <li class="divider"></li>
                <li><a href="/articles/">文章</a></li>
                <li><a href="/support/faq.html">FAQ</a></li>
              </ul>
            </li>
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">
                                       工具
              </a>
              <ul class="dropdown-menu">
                <i class="sprite-icon-dd-tip"></i>
                <li><a href="/docs/dart-up-and-running/contents/ch04-tools-dart2js.html">dart2js</a>
                </li><li><a href="/tools/editor/">Dart Editor</a></li>
                <li><a href="http://pub.dartlang.org/">Pub Package Manager</a></li>
                <li><a href="/tools/">更多工具</a></li>
              </ul>
            </li>
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">
                                                     资源
              </a>
              <ul class="dropdown-menu">
                <i class="sprite-icon-dd-tip"></i>
                <li><a href="/samples/">示例代码</a></li>
                <li><a href="/docs/synonyms/">和其他语言的相同点</a></li>

                <li class="divider"></li>
                <li><a href="/slides/">演示文稿</a></li>
                <li><a href="/dart-tips/">Dart 短视频</a></li>

                <li class="divider"></li>
                <li><a href="/performance/">性能</a></li>
                <li class="divider"></li>
                <li><a href="http://code.google.com/p/dart/issues/list">Bugs and Feature Requests</a></li>
              </ul>
            </li>
            <li class="dropdown">
              <a href="/support/" title="Community and Support">
                                              支持
              </a>
            </li>
          </ul>

          <ul class="nav navbar-nav navbar-right">
            <li>
              <form class="navbar-search" action="/search.html" id="cse-search-box">
                <input type="hidden" name="cx" value="011220921317074318178:i4mscbaxtru">
                <input type="hidden" name="ie" value="UTF-8">
                <input type="hidden" name="hl" value="en">
                <input type="search" name="q" class="search-query placeholder-position-fix form-control" id="q" autocomplete="off" placeholder="Search">
              </form>
            </li>
            <li><a target="_blank" href="https://twitter.com/dart_lang" class="btn"><i class="sprite-icon-social-twitter"></i></a></li>
            <li><a target="_blank" href="https://plus.google.com/+dartlang/posts" class="btn"><i class="sprite-icon-social-gplus"></i></a></li>
            <li><a target="_blank" href="http://weibo.com/cndart" class="btn"><i class="sprite-icon-social-weibo"><img src="/imgs/weibo.png"></i></a></li>
          </ul>
        </div><!-- /.nav-collapse -->

      </div><!-- /.container -->
    </div><!-- /.navbar -->

  


<div class="container-page">
  <div class="container">
  	<div class="container sub-page">
      <div class="row">
        <article class="has-permalinks"><div class="col-md-3">
  <div class="bs-sidebar hidden-print affix-top" role="complementary">

<ol class="toc nav bs-sidenav" id="markdown-toc">
  <li><a href="#section">构造函数</a>    <ol>
      <li><a href="#section-1">自动的成员初始化</a></li>
      <li><a href="#section-2">命名构造函数</a></li>
      <li><a href="#section-3">工厂构造函数</a></li>
    </ol>
  </li>
  <li><a href="#functions">方法(Functions)</a>    <ol>
      <li><a href="#section-4">一行代码的函数</a></li>
      <li><a href="#section-5">方法类型和别名</a></li>
    </ol>
  </li>
  <li><a href="#section-6">类型定义</a></li>
  <li><a href="#getters-setters">成员变量、 getters、和 setters</a></li>
  <li><a href="#top-level">顶级（Top-level）定义</a></li>
  <li><a href="#section-7">依赖注入</a></li>
  <li><a href="#section-8">字符串和插值</a></li>
  <li><a href="#section-9">操作符</a></li>
  <li><a href="#section-10">相等判断</a></li>
  <li><a href="#section-11">数字</a></li>
  <li><a href="#futures">Futures</a></li>
  <li><a href="#section-12">注释</a></li>
</ol>

  </div>
</div>
<div class="col-md-7">
  <p><!-- Start of content -->
	</p>

  <h1 id="dart-">Dart 习惯用法</h1>

  <p><em>作者： Bob Nystrom<br />
译者：云在千峰<br />
2011 10月
(2013 3月更新)</em></p>

  <p>Dart 设计的时候就借鉴了其他语言，如果你用过其他语言 – 特别是 Java 和 JavaScript – 
就可以发现 Dart 看起来比较熟悉。
如果你努力尝试的话，你可以完全按照这些语言来用 Dart；
如果你_再努力尝试下_的话，你也可以按照 Fortran 的方式来用 Dart，
但是如果这样的话，就丧失了 Dart 的独特性和趣味性了。</p>

  <p>这篇文章介绍如何编写独特适合 Dart 的代码。
由于该应用仍然还在进化，很多习惯语法也在发生变化。
仍然有一些地方我们目前还不确定如何做是最好的。（也许
你可以帮助我们。）
但是，这里的一些观点也许会让你从 Java 或者 JavaScript 中摆脱出来并为之眼前一亮，
从而进入到 Dart 世界。</p>

  <aside class="alert alert-info">
    <p><strong>注意</strong>：
 该文章并不是要告诉你 Dart 编程的基本内容。
 如果你还没接触过 Dart ，我们推荐你先
 看看
  <a href="/docs/dart-up-and-running/">Dart 语言概览</a>。</p>
  </aside>

  <h2 id="section">构造函数</h2>

  <p>先从构造函数开始。每个对象都是在某个地方创建的，
定义构造函数是一个对象的重要组成部分。
关于构造函数，Dart 有一些很有趣
的观点。</p>

  <h3 id="section-1">自动的成员初始化</h3>

  <p>首先就是去除一些繁琐的初始化过程。
很多构造函数都是简单的把参数赋值给成员变量，例如：</p>

  <pre class="prettyprint lang-dart">class Point {
  num x, y;
  Point(num x, num y) {
    this.x = x;
    this.y = y;
  }
}</pre>

  <p>这里为了给一个变量赋值，我们不得不写_四_次 <code>x</code>。真无聊啊！在 Dart 中，
我们做的更好：</p>

  <pre class="prettyprint lang-dart">class Point {
  num x, y;
  Point(this.x, this.y);
}</pre>

  <p>如果构造函数的参数名字之前带有 <code>this.</code>，则对应的成员变量会用该参数的值
自动初始化。
该示例还演示了其他一个小特性：
如果构造函数体是空的，你可以用一个分号 (<code>;</code>) 来替代 <code>{}</code>。</p>

  <h3 id="section-2">命名构造函数</h3>

  <p>和其他很多动态类型语言一样， Dart 不支持重载（overloading）。
针对函数来说，不支持重载不是问题，你可以选择另外一个名字。但是 构造函数就没这么幸运了。
为了弥补该不足之处， Dart 让你可以定义_命名构造函数_：</p>

  <pre class="prettyprint lang-dart">import 'dart:math';

class Point {
  num x, y;
  Point(this.x, this.y);
  Point.zero() : x = 0, y = 0;
  Point.polar(num theta, num radius) {
    x = cos(theta) * radius;
    y = sin(theta) * radius;
  }
}</pre>

  <p>上面的 Point 类有三个构造函数，一个普通的和两个命名构造函数。
你可以这样使用他们：</p>

  <pre class="prettyprint lang-dart">import 'dart:math';

main() {
  var a = new Point(1, 2);
  var b = new Point.zero();
  var c = new Point.polar(PI, 4.0);
}</pre>

  <p>注意，当调用命名构造函数的时候，我们依然用 <code>new</code> 关键字。
他们不只是一个静态函数。</p>

  <h3 id="section-3">工厂构造函数</h3>

  <p>有很多关于_工厂_的设计模式。
当你需要一个类的实例而又不想绑定到具体的实现中去（想要
一些灵活性），则可以用到这些模式。
例如 已经缓存了一个实例了，则就使用缓存的示例；
或者你想用一个不同类型的实现。</p>

  <p>当用 Dart 创建对象的时候，
Dart 无需改变调用代码就支持工厂模式。
例如，你可以定义一个_工厂构造函数_。当_调用_该函数的时候，
用起来就和一般的构造函数一样。但是，该构造函数的实现可以做任意事情。例如：</p>

  <pre class="prettyprint lang-dart">class Symbol {
  final String name;
  static Map&lt;String, Symbol&gt; _cache;

  factory Symbol(String name) {
    if (_cache == null) {
      _cache = {};
    }

    if (_cache.containsKey(name)) {
      return _cache[name];
    } else {
      final symbol = new Symbol._internal(name);
      _cache[name] = symbol;
      return symbol;
    }
  }

  Symbol._internal(this.name);
}</pre>

  <p>上面是一个定义符号的类。一个符号就像一个字符串，但是我们确保
对于同样的名字只有一个符号对象存在。
这样你可以只用比较两个符号是否是同一个对象就可以知道他们
是否相同。</p>

  <p>这个默认的构造函数用 <code>factory</code> 来修饰。
这样 Dart 就知道该函数为一个 工厂构造函数。 当调用该函数的时候，它_不会_创建
一个新的对象（在工厂构造函数内没有 <code>this</code> 变量）。相反，
你需要自己创建一个对象并返回。这里查找之前缓存的对象，
如果发现已经存在了就返回查找到的实例。</p>

  <p>比较酷的是，_调用者_不知道这一切。他们只是这样调用：</p>

  <pre class="prettyprint lang-dart">var a = new Symbol('something');
var b = new Symbol('something');

assert(identical(a, b)); // true!</pre>

  <p>第二个 <code>new</code> 只会返回前面缓存的对象。
该特性比较好的是，如果一开始我们不知道需要一个工厂构造函数，
而后面我们发现我们需要这样做的时候，我们只需要把
该构造函数设置为工厂构造函数即可，而不需要修改调用者的代码。</p>

  <h2 id="functions">方法(Functions)</h2>

  <p>和许多新型的语言一样， Dart 的类等方法（first-class function）完全支持
闭包并使用轻量级的语法。方法和其他东西一样都是对象，
你应该毫不犹豫的使用他们。</p>

  <p>Dart 有三种创建方法的方式：</p>

  <ul>
    <li>命名方法</li>
    <li>具有方法体的匿名方法</li>
    <li>表达式方法，通常称之为 <em>arrow functions（箭头方法）</em></li>
  </ul>

  <p>命名方法看起来如下：</p>

  <pre class="prettyprint lang-dart">bool isShouting(String message) {
  return (message.toUpperCase() == message);
}</pre>

  <p>上面的代码看起来和 Java C 语言中的函数没啥区别。
你可以用常用的方式来调用方法：</p>

  <pre class="prettyprint lang-dart">print(isShouting(&quot;I'M JUST VERY EXCITED&quot;)); // true</pre>

  <p>在 Dart 中，方法是对象，所以你可以把他们当做参数来传递：</p>

  <pre class="prettyprint lang-dart">var messages = ['hello', 'DART IS FUN'];
var shouts = messages.where(isShouting).toList();

print(shouts); // ['DART IS FUN']</pre>

  <p>如果你无须给方法命名，则可以用匿名方法。
看起来和命名方法类似，但是没有名字和返回值类型。
下面是一个示例：</p>

  <pre class="prettyprint lang-dart">var shouts2 = messages.where((m) {
  return (m.toUpperCase() == m);
}).toList();</pre>

  <p>最后，如果你只需要执行一个表达式并返回一个值，则可以使用轻量
级语法 <code>=&gt;</code>：</p>

  <pre class="prettyprint lang-dart">var shouts3 = messages.where((m) =&gt; m.toUpperCase() == m).toList();</pre>

  <p>一个圆括号包围的参数列表，后面跟着一个  <code>=&gt;</code> 和一个表达式。
这样就创建了一个使用这些参数的方法，并
返回该表达式的值。</p>

  <p>在实际工作中，由于箭头方法很简洁并且 <code>=&gt;</code> 很容易识别， 我们发现我们非常喜欢箭头
方法。
我们经常把匿名方法用作 事件处理函数和回调函数。</p>

  <p>更多信息，参考
<a href="/docs/dart-up-and-running/contents/ch02.html#functions">Dart 中的方法</a>。</p>

  <h3 id="section-4">一行代码的函数</h3>

  <p>Dart 还有一个我非常喜欢的特性：
可以用 <code>=&gt;</code> 来定义函数。
当然你_可以_这样做：</p>

  <pre class="prettyprint lang-dart">class Rectangle {
  num width, height;

  bool contains(num x, num y) {
    return (x &lt; width) &amp;&amp; (y &lt; height);
  }

  num area() {
    return width * height;
  }
}</pre>

  <p>但是当你可以这样干的时候，为啥还那样呢？</p>

  <pre class="prettyprint lang-dart">class Rectangle {
  num width, height;
  bool contains(num x, num y) =&gt; (x &lt; width) &amp;&amp; (y &lt; height);
  num area() =&gt; width * height;
}</pre>

  <p>我们发现箭头函数非常适合 getter 和其他只有一行
代码的函数。</p>

  <h3 id="section-5">方法类型和别名</h3>

  <p>不要忘记了， Dart 可以把方法当做参数。
下面是一个示例：</p>

  <pre class="prettyprint lang-dart">List&lt;num&gt; filterNumbers(List&lt;num&gt; numbers, bool filter(num x)) {
  return numbers.where(filter).toList();
}</pre>

  <p>上面的代码是正确的，如果可以把 <code>filter</code> 的类型提取出来则看起来会比较简洁。
当些代码的时候，你不知道过滤方法的参数类型。所有，你
没法说 <code>if (filter is bool filter(num x))</code>。
另外，用 <code>filterNumbers</code> 则显得有点复杂。</p>

  <p>为了提供简洁的方法签名，并提供更多的类型信息，你可以用_typedef<em>。
一个 _typedef</em> 本质上为
一个方法签名提供了一个别名。</p>

  <pre class="prettyprint lang-dart">typedef bool Filter(num x);

List&lt;num&gt; filterNumbers(List&lt;num&gt; numbers, Filter filter) {
  return numbers.where(filter).toList();
}</pre>

  <p>现在，你可以用 <code>if (filter is Filter)</code>了。</p>

  <p>无论何时创建一个能接受方法的变量时，都可以用 
typedef 来定义方法的签名。
下面的示例来自于 Dart Web UI 库：</p>

  <pre class="prettyprint lang-dart">/** Function to set up the contents of a conditional template. */
typedef void ConditionalBodySetup(ConditionalTemplate template);

/**
 * A template conditional like `&lt;template instantiate=&quot;if test&quot;&gt;` or
 * `&lt;td template instantiate=&quot;if test&quot;&gt;`.
 */
class ConditionalTemplate extends PlaceholderTemplate {
  bool isVisible = false;
  final ConditionalBodySetup bodySetup;

  ConditionalTemplate(Node reference, exp, this.bodySetup)
      : super(reference, exp);

  ...</pre>

  <h2 id="section-6">类型定义</h2>

  <p>如果你可以这样写代码：</p>

  <pre class="prettyprint lang-dart">// Dart

String MakeGreeting(String name) {
  String greeting = 'hello $name';
  return greeting;
}</pre>

  <p>为什么还要这样写呢？</p>

  <pre class="prettyprint lang-javascript">// JavaScript w/ Closure compiler

/**
 * @param {String} name
 * @return {String}
 */
makeGreeting = function(name) {
  /** @type {String} */
  var greeting = 'hello ' + name;
  return greeting;
}</pre>

  <p>Dart 是可选类型语言，这意味着用户不用总是
需要处处检测类型就可以运行代码了。使用类型当做
“内置的文档”可以帮助你的同事或者工具理解你的
代码。</p>

  <p>一般来说， <strong>在你代码的”暴露不用” 使用类型</strong>。
如果其他的开发者需要用到你的接口，则用类型注解。
这样他们会感激你的。</p>

  <p>在函数内部，该规则是比较灵活的。如果你想用类型就用吧，
如果团队代码风格允许的话，你也可以只用 <code>var</code>。
即使你用 <code>var</code> ，智能的编辑器和静态分析工具也能
为你提供一些代码建议。</p>

  <p>如果，你想表达一些系统类型无法表达的东西时， 你可以完全忽略类型。
例如，如果你的函数既可以接收 整数 也可以接收一个 Duration，则
你可以把参数类型设置为 <code>var</code>。</p>

  <pre class="prettyprint lang-dart">/// This method used to only take an [int] but now it takes a [Duration] or
/// [int]. Use of [int] is deprecated, please use [Duration].
calculateTimePeriod(var duration) {
  if (duration is int) {
    // ...
  } else if (duration is Duration) {
    // ...
  } else {
    throw new ArgumentError('duration must be an int or Duration');
  }
}</pre>

  <p>在 API 进化中这是常见的场景。当 API 确定后，你
可以确定其类型了。</p>

  <p>更多信息参考 <a href="/articles/optional-types/">Dart 可选静态类型</a>。</p>

  <h2 id="getters-setters">成员变量、 getters、和 setters</h2>

  <p>Dart 用标准的 <code>object.someProperty</code> 语法来访问
成员变量。在大部分语言中，当  <code>someProperty</code>是该对象的真实成员变量的时候才有效，
但是 Dart 也允许你定义看起来和访问成员变量一样的函数。
在其他语言中，这些函数被称之为 <em>getters</em> 和 <em>setters</em>。
下面是一个示例：</p>

  <pre class="prettyprint lang-dart">class Rectangle {
  num left, top, width, height;

  Rectangle(this.left, this.top, this.width, this.height);

  num get right             =&gt; left + width;
      set right(num value)  =&gt; left = value - width;
  num get bottom            =&gt; top + height;
      set bottom(num value) =&gt; top = value - height;
}</pre>

  <p>这里定义了一个 Rectangle 类，该类有四个成员变量 - <code>left</code>、 <code>top</code>、 <code>width</code>、
和 <code>height</code>。该类还使用 getters 和 setters 定义了另外两个虚拟成员变量：
<code>right</code> 和 <code>bottom</code>。在使用这个类的时候，
你不知道”真实”成员变量和 getters 、 setters 有啥区别：</p>

  <pre class="prettyprint lang-dart">var rect = new Rectangle(3, 4, 20, 15);
print(rect.left);
print(rect.bottom);
rect.top = 6;
rect.right = 12;</pre>

  <p>这种模糊了成员变量和 getters/setters 之间界限的机制是该语言的基础。
理解该机制比较清楚的观点是：成员变量_只是_ getters/setters 的默认实现。
这样，你可以实现一些有趣的功能，例如 用一个变量来重写一个继承的 getter。
如果一个接口定义了一个 getter 函数，则你可以用一个同样名字和类型 成员变量 来重写该函数。
如果变量是可变的（没有 <code>final</code>），则还可以实现一个 setter 函数。</p>

  <p>在实际应用中，你无须只是为了隐藏成员变量而为他们提供一个无聊的 getters 和 setters 函数，
例如 Java 和 C# 就是
这样的。
如果你有一些需要暴露的成员变量，可以直接设置为 public 的。如果
你不想让其他人修改，则设置为 <code>final</code> 的。 </p>

  <p>以后，如果你想做一些验证或者其他功能，你可以把该成员变量替换为 getter 和 setter。
例如，如果我们希望 Rectangle 类没有负的尺寸， 则我们可以这样修改代码：</p>

  <pre class="prettyprint lang-dart">class Rectangle {
  num left, top;
  num _width, _height;

  Rectangle(this.left, this.top, this._width, this._height);

  num get width =&gt; _width;
  set width(num value) {
    if (value &lt; 0) throw 'Width cannot be negative.';
    _width = value;
  }

  num get height =&gt; _height;
  set height(num value) {
    if (value &lt; 0) throw 'Height cannot be negative.';
    _height = value;
  }

  num get right             =&gt; left + width;
      set right(num value)  =&gt; left = value - width;
  num get bottom            =&gt; top + height;
      set bottom(num value) =&gt; top = value - height;

}</pre>

  <p>这样我们修改了该类来实现一些验证功能，而无需修改任何使用该类的
代码。</p>

  <h2 id="top-level">顶级（Top-level）定义</h2>

  <p>Dart 是一个 “纯” 面向对象语言，可以放到变量的任意值都是对象（”primitives” 除外），
并且任意对象都是某个类的实例。Dart 不是一个_dogmatic（教条式）_的面向对象语言。
不需要把任何东西都定义到一个类中。你可以随意的定义
顶级方法、函数、变量、甚至 getter 和 setter。</p>

  <pre class="prettyprint lang-dart">import 'dart:math';

num abs(num value) =&gt; value &lt; 0 ? -value : value;

final TWO_PI = PI * 2.0;

int get today {
  final date = new DateTime.now();
  return date.day;
}

main() {
  print(today);
}</pre>

  <p>在一些你不需要把任意定义都放到类中的语言中，例如 JavaScript，通常也需要
定义一个命名空间：防止具有相同名字的顶级定义会冲突。
为了解决该问题， Dart 实现了一个可以带有前缀名称导入的库系统。
这样你就_无需_防御性的把你的函数定义到一个类中了。</p>

  <p>最常见的顶级函数就是 <code>main()</code>。如果你使用 DOM，
像 <code>document</code> 和 <code>window</code> 这些”变量”都是定义在 Dart 的顶级 getter。
以前 Dart 有一个 Math 类，后来我们把该类的所有函数都放到 dart:math 库的
顶级函数中了。</p>

  <h2 id="section-7">依赖注入</h2>

  <p>你可以组合 typedef、方法和构造函数来定义一个简单的
_依赖注入_系统。如下示例：</p>

  <pre class="prettyprint lang-dart">typedef Connection ConnectionFactory();

Connection _newDBConnection() =&gt; new DatabaseConnection();

class Person {
  String id;
  String name;
  ConnectionFactory connectionFactory;

  Person({this.connectionFactory: _newDBConnection});

  Future save() {
    var conn = connectionFactory();
    return conn.query('UPDATE PERSONS SET name = ? WHERE id = ?', [name, id]);
  }
}</pre>

  <p>上面的简单示例演示了很多 Dart 中的酷特性：</p>

  <dl>
    <dt>Typedefs</dt>
    <dd>用来创建一个返回数据库连接的方法别名。</dd>
    <dt>可选命名参数</dt>
    <dd>用来设置默认的数据库连接工厂，或者用一个用户设置的工厂方法。</dd>
    <dt>顶级方法</dt>
    <dd>用来定义默认的数据库连接工厂方法</dd>
  </dl>

  <h2 id="section-8">字符串和插值</h2>

  <p>Dart 有一些字符串字面量。你可以用单引号或者双引号来定义字符串，
也可以用三个单引号来定义跨行的字符串：</p>

  <pre class="prettyprint lang-dart">var s1 = 'I am a &quot;string&quot;'
&quot;I'm one too&quot;;

var s2 = '''I'm
on multiple lines
''';

var s3 = &quot;&quot;&quot;
As
am
I
&quot;&quot;&quot;;</pre>

  <p>尽管在 String 上还有一个加号(+)操作符，但是用_字符串插值_是更简洁高效的方式：</p>

  <pre class="prettyprint lang-dart">var name = 'Fred';
var salutation = 'Hi';
var greeting = '$salutation, $name';</pre>

  <p>在字符串字面量中的美元符号 (<code>$</code>)后跟一个变量名字代表一个变量的值。
 (如果变量不是 string 对象，则调用 <code>toString()</code>函数。)
 你也可以把表达式放到花括号中来插值表达式的值：</p>

  <pre class="prettyprint lang-dart">import 'dart:math';
main() {
  var r = 2;
  print('The area of a circle with radius $r is ${PI * r * r}');
}</pre>

  <h2 id="section-9">操作符</h2>

  <p>Dart 的操作符和优先级和你熟悉的语言一样，例如 Java 、 C 等。
这样，他们符合你期望的行为。但是在表面之下，他们还有一些特殊用法。
在 Dart 中，类似 <code>1 + 2</code> 这种使用操作符的表达式只是调用函数的语法糖。
这个例子类似于语言中的 <code>1.+(2)</code>。</p>

  <p>这就意味着，大部分情况下你都可以重写自定义类型的操作符。
例如，下面是一个自定义的 <code>Vector</code> 类：</p>

  <pre class="prettyprint lang-dart">class Vector {
  num x, y;
  Vector(this.x, this.y);
  operator +(Vector other) =&gt; new Vector(x + other.x, y + other.y);
}</pre>

  <p>这样，我们可以用熟悉的语法来把两个 Vector 相加：</p>

  <pre class="prettyprint lang-dart">var position = new Vector(3, 4);
var velocity = new Vector(1, 2);
var newPosition = position + velocity;</pre>

  <p>话虽如此，但不要太疯狂了。我们给你车的钥匙并且
相信你不会瞎搞乱撞。</p>

  <p>在实际中，如果你定义的类型在”真实世界”（在黑板上？）中经常使用操作符，则很可能该
类型很适合重写操作符：例如 复数、向量、矩阵 等等。
否则，可能不适合重写操作符。使用自定义操作符的类型通常也应该是不可变的。</p>

  <p>注意，操作符调用只是普通的函数调用，所以他们本质上具有不对称性。
总是在左边的参数上查找函数。所以当你用  <code>a + b</code>，
则由类型 <code>a</code>来确定实现何种功能。</p>

  <h2 id="section-10">相等判断</h2>

  <p>Dart 有两种相等判断操作符：
<code>==</code> 和 <code>!=</code>。
和 JavaScript 的相等操作符有点差别。
和 JavaScript 不同， Dart 没有 <code>===</code> 操作符，而是提供了
一个顶级方法 <code>identical()</code>。</p>

  <p>用 <code>==</code> 和 <code>!=</code> 来测试相等。在 99% 的情况下他们都能满足你的需求。
和 JavaScript 不同，他们不会做任何潜在的转化，所以他们和你期望的行为一致。
所以 大胆的用吧。
和 <em>Java</em> 也不同，他们可以在任意定义了相等关系的类型使用。
告别 <code>someString.equals("something")</code> 吧。</p>

  <p>如果有意义，你可以在自定义类型中实现 <code>==</code>。
但是你无须实现 <code>!=</code>：Dart 会从 <code>==</code> 的实现中自动推断  <code>!=</code>。
如果你自己实现了 <code>==</code>，不要忘了同时实现
<a href="http://api.dartlang.org/dart_core/Object.html#hashCode">hashCode</a>。</p>

  <p><code>identical() 函数用来测试两个对象是否_是内存中的同一个对象_。
实际上，你很少使用这种测试。 Object 类定义 </code>==<code> 返回 </code>identical(this, other)<code>，
所以，只有当你重写 </code>==<code> 或者 避免重写 </code>==<code> 的时候才需要调用 </code>identical()`。</p>

  <h2 id="section-11">数字</h2>

  <p>Dart 有个 <code>num</code> 类和两个子类：<code>int</code> 、 <code>double</code>。
整数在 VM 中可以是任意大小，double 为 IEEE 754 标准定义的 64-bit double。</p>

  <p>在常规的 Dart 代码中，我们发现需要两种类型的数字：</p>

  <ol>
    <li>没有小数点的整数。例如：用于列表索引的整数。</li>
    <li>任何数字，包含带小数点的。</li>
  </ol>

  <p>第一种情况使用 <code>int</code> ，第二种情况用  <code>num</code>。
只有极少数情况我们才需要一个数字_必须_带小数点儿
_不能_为整数，这种情况才需要用 double。</p>

  <p>Dart 中的数字通常都是 <code>int</code> 或者 <code>num</code>，
极少情况下才会是 <code>double</code>。</p>

  <h2 id="futures">Futures</h2>

  <p>Future 代表未来某个时候会返回一个值。</p>

  <p>用 Future 的函数应该总是返回 Future。这样可以帮助调用者来
处理错误的情况。也可以让调用者知道
何时该操作完成。</p>

  <pre class="prettyprint lang-dart">Future doLengthyComputation() {
  return lengthyComp().then((value) =&gt; print(value))
                      .catchError((e) =&gt; print(e));
}</pre>

  <p>总是把 <code>catchError()</code> 级联在
<code>then()</code> 之后调用，否则你会丢失在 <code>then()</code> 中抛出的异常。</p>

  <p>下面是一个 <strong>不要这么干</strong> 的反面示例：</p>

  <pre class="prettyprint lang-dart">// WARNING: This code contains an anti-pattern.
Future doLengthyComputation() {
  Future future = lengthyComp();
  future.then((value) =&gt; print(value));

  // BAD! You'll only get errors from future, not from then().
  // BAD! Your caller never sees any errors that occur.
  future.catchError((e) =&gt; print(e));
  return future;
}</pre>

  <p>如果你想在”未来”运行一个函数， <code>Timer.run</code> 将会诱惑你使用它。
除非你知道你在干啥，否则<strong>不要用</strong>。
非常不幸的是，在 run 回调函数中的异常通常或多或少的不好捕获。</p>

  <p>非常幸运的是， Future 有个构造函数可以帮助我们。
<code>Future.delayed</code> 函数可以在未来运行一个函数而无需丢失
可能抛出的异常。</p>

  <pre class="prettyprint lang-dart">Future doLengthyComputation() {
  return new Future.delayed(const Duration(seconds: 0),
      () =&gt; doTheThingThatMightFail());
}</pre>

  <h2 id="section-12">注释</h2>

  <p>Dart 支持可被工具解析的结构化注释。
然而，为了用更流畅和更自然的注释， Dart 避免正式的 API 文档。</p>

  <p>对比 Java 和 Dart 的注释风格：</p>

  <div class="row">
    <div class="col-md-6">
      <pre class="prettyprint lang-java">/**
 * Returns an Llama object that can then be petted. 
 * The age argument must specify an non-zero integer. The amount
 * argument is the amount of {@link Money} paid for the llama.
 * &lt;p&gt;
 * This method throws {@link NoMoreLlamasException} is thrown
 * if there are no more llamas to purchase.
 * {@link IllegalArgumentException} is
 * thrown if age is less than zero.
 *
 * @param  age  a non-zero age
 * @param  amount the amount of money paid for the llama
 * @throws NoMoreLlamasException if there are no more llamas available
 * @throws IllegalArgumentException if age is less than zero
 * @return      the llama
 * @see         Farmer
 */
 public Llama buyLlama(Age age, Money amount) {
   // ...
 }</pre>
    </div>
    <div class="col-md-6">
      <pre class="prettyprint lang-dart">/**
 * Returns a Llama that can be petted.
 * An [ArgumentError] is thrown if age is less than zero, and
 * [NoMoreLlamasError] is thrown if they are all out of llamas.
 */
Llama buyLlama(int age, Money amount) {
  // ...
}</pre>
    </div>
  </div>

  <p>Dart 文档注释使用了 少即是多 的原则。无需一遍又一遍的重复你的描述，
只需要在注释中说明你需要啥即可。
同时，也无需在文档注释中用 HTML 标签； Dart 的 dartdoc 工具可以理解
一些 Markdown 语法。</p>

  <pre class="prettyprint lang-dart">/**
 * ## Examples
 *
 * Getting the _value_:
 *
 *     Future&lt;int&gt; future = getFutureFromSomewhere();
 *     future.then((value) {
 *       print(&quot;I received the number $value&quot;);
 *     });
 * ...
 */</pre>

  <p>了解更多 <a href="/articles/doc-comment-guidelines/">Dart 注释风格</a>。</p>
</div>

    	  </div> <!-- End of content from toc.html -->
        </article>
	  </div>

	
	<ul class="pager">
	  <li><a href="/articles/">关于 Dart 的更多文章 <i class="glyphicon glyphicon-chevron-up"></i></a></li>
	 </ul>
	 

	</div>
  </div>
</div>

  <footer class="footer container-full">
    <div class="container">
      <div class="row">
        <div class="col-md-5">
          <h3>一种用于创建可扩展 web 应用程序的语言、工具和代码库</h3>
          <p>Dart 是一个 <a href="https://code.google.com/p/dart/">开源项目</a>，由  Google 和其他人员参与。</p>
          <p class="sm">除非注明，该页面内容使用 the Creative Commons Attribution 3.0 License 发布，示例代码使用  BSD License 发布。</p>
          <!-- 
          <p><a class="saelogo" href="http://sae.sina.com.cn/activity/invite/15649/weibo" target="_blank"><img src="http://static.sae.sina.com.cn/image/poweredby/poweredby.png" title="Powered by Sina App Engine"></a></p>     	
          -->
        </div>
        <div class="col-md-2 col-md-offset-1">
          <h4>受欢迎的文章</h4>
          <ul>
            <li><a href="/polymer-dart/?utm_source=site&amp;utm_medium=footer&amp;utm_campaign=homepage">Polymer.dart</a></li>
            <li><a href="/performance/">性能</a></li>
            <li><a href="/docs/dart-up-and-running/contents/ch02.html?utm_source=site&amp;utm_medium=footer&amp;utm_campaign=homepage">语言概览</a> &amp;
            <a href="/docs/dart-up-and-running/contents/ch03.html?utm_source=site&amp;utm_medium=footer&amp;utm_campaign=homepage">代码库概览</a></li>
            <li><a href="/samples/?utm_source=site&amp;utm_medium=footer&amp;utm_campaign=homepage">示例代码</a></li>
            <li><a href="/docs/tutorials/?utm_source=site&amp;utm_medium=footer&amp;utm_campaign=homepage">教程</a> &amp;
                <a href="/codelabs/darrrt/?utm_source=site&amp;utm_medium=footer&amp;utm_campaign=homepage">代码实验室</a></li>
          </ul>
        </div>
        <div class="col-md-2">
          <h4>资源</h4>
          <ul>
            <li><a href="http://pub.dartlang.org/">Pub packages</a></li>
            <li><a href="/docs/synonyms/">和其他语言的相同点</a></li>
            <li><a href="http://code.google.com/p/dart/issues/list">Dart bugs and feature requests</a></li>
          </ul>
        </div>
        <div class="col-md-2">
          <h4>社区</h4>
          <ul>
            <li><a href="/support/">邮件列表</a></li>
            <li><a href="http://forum.dartlang.cc">中文社区</a></li>
            <li><a href="http://weibo.com/cndart">中文微博</a></li>
            <li><a href="https://plus.google.com/communities/114566943291919232850">G+ 社区</a></li>
            <li><a href="https://plus.google.com/+dartlang/posts">G+ 新闻发布频道</a></li>
            <li><a href="http://stackoverflow.com/questions/tagged/dart">Stack Overflow</a></li>
          </ul>
        </div>
      </div>
    </div>
  </footer> <!-- End footer -->

<script type='text/javascript' src='/js/jquery.js'></script>
<script type='text/javascript' src='/js/bootstrap.min.js'></script>
<script type='text/javascript' src='/js/prettify.js'></script>
<script type='text/javascript' src='/js/lang-dart.js'></script>
<script type='text/javascript' src='/js/lang-yaml.js'></script>
<script type='text/javascript' src='/js/scripts.js'></script>




<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F76b2695e71e6cec6e6af036d76afa367' type='text/javascript'%3E%3C/script%3E"));
</script>

<!-- Baidu Button BEGIN -->
<script type="text/javascript" id="bdshare_js" data="type=slide&amp;img=1&amp;pos=left&amp;uid=590574" ></script>
<script type="text/javascript" id="bdshell_js"></script>
<script type="text/javascript">
var bds_config={"bdTop":367};
document.getElementById("bdshell_js").src = "http://bdimg.share.baidu.com/static/js/shell_v2.js?cdnversion=" + Math.ceil(new Date()/3600000);
</script>
<!-- Baidu Button END -->
</body>
</html>

