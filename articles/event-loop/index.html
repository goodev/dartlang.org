<!DOCTYPE html>
<html lang="en" itemscope itemtype="http://schema.org/Product" xmlns:wb="http://open.weibo.com/wb">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  
  <title>The Event Loop and Dart | Dart: 用于创建结构化的web应用</title>
  <meta property="wb:webmaster" content="a984f6440858ee44" />
  <meta property="twitter:account_id" content="376585411" />
  <meta itemprop="name" content="The Event Loop and Dart | Dart: 用于创建结构化的web应用">
  
  <meta itemprop="image" content="https://www.dartlang.org/imgs/dart-logo-wordmark-1200w.png">
  
  <meta itemprop="description" content="Learn how Dart handles the event queue and microtask queue, so you can write better asynchronous code with fewer surprises.">


  <link rel='stylesheet' type='text/css' href='/css/bootstrap.min.css'>
<link rel='stylesheet' type='text/css' href='/css/dart-style.css'>
<link rel='stylesheet' type='text/css' href='/css/prettify.css'>
<link rel='stylesheet' type='text/css' href='/css/font-awesome.min.css'>

  
    <link href="//fonts.googleapis.com/css?family=Montserrat:400,700|Roboto:300,400" rel="stylesheet">

	
	<link rel="author" href="/authors/kathy-walrath.html">
	
	<link rel="alternate" type="application/atom+xml" href="http://dartnews.sinaapp.com/?feed=atom" title="Atom feed">
  <!-- 
  <link href="https://plus.google.com/109866369054280216564" rel="publisher">
  -->
  <link href="http://weibo.com/cndart" rel="publisher">

  <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!--[if lt IE 9]>
    <script src="js/html5shiv.js"></script>
    <script src="js/respond.min.js"></script>
  <![endif]-->

  <!-- 
<script type="text/javascript">

  //var _gaq = _gaq || [];
 // _gaq.push(['_setAccount', 'UA-26406144-4']);
  //_gaq.push(['_setDomainName', 'dartlang.org']);
  //_gaq.push(['_setSiteSpeedSampleRate', 50]);
  //_gaq.push(['_trackPageview']);

 // (function() {
   // var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
   // ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
   // var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
 // })();

</script>
-->


  <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
</head>
<body onload="prettyPrint()">
    <div class="navbar navbar-fixed-top navbar-inverse" role="navigation">
      <div class="container">
        
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="/"><i class="sprite-icon-dart-logo"></i></a>
        </div>

        <div class="collapse navbar-collapse">
          <ul class="nav navbar-nav">
           <li class="dropdown">
              <a href="/codelabs/darrrt/" title="Learn Dart in this short code lab.">
                                                       入门
              </a>
            </li>
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">
                                                文档 <span class="caret"></span>
              </a>
              <ul class="dropdown-menu">
                <i class="sprite-icon-dd-tip"></i>
                <li><a href="/docs/tutorials/">教程</a></li>
                
                <i class="sprite-icon-dd-tip"></i>
                <li><a href="/dart-by-example/">Dart 示例</a></li>
                
                <li class="divider"></li>
                <li><a href="/docs/">开发者指南</a></li>
                <li><a href="http://api.dartlang.org">API 参考</a></li>
                <li><a href="/docs/spec/">语言规范</a></li>

                <li class="divider"></li>
                <li><a href="/docs/dart-up-and-running/">Dart: Up and Running</a></li>
                <li><a href="/books/">更多图书</a></li>

                <li class="divider"></li>
                <li><a href="/articles/">文章</a></li>
                <li><a href="/support/faq.html">FAQ</a></li>
              </ul>
            </li>
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">
                                       工具  <span class="caret"></span>
              </a>
              <ul class="dropdown-menu">
                <i class="sprite-icon-dd-tip"></i>
                <li><a href="/tools/download.html">下载 Dart</a></li>
                <li class="divider"></li>
                </li><li><a href="/tools/editor/">Dart Editor</a></li>
                <li><a href="http://pub.dartlang.cc/">Pub 包管理器</a></li>
                <li><a href="/docs/dart-up-and-running/contents/ch04-tools-dart2js.html">dart2js</a>
                <li><a href="/tools/faq.html">工具 FAQ</a></li>
              </ul>
            </li>
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">
                                                     资源  <span class="caret"></span>
              </a>
              <ul class="dropdown-menu">
                <i class="sprite-icon-dd-tip"></i>
                <li><a href="/samples/">示例代码</a></li>
                <li><a href="/docs/synonyms/">和其他语言的相同点</a></li>
                <li><a href="/performance/">性能</a></li>

                <li class="divider"></li>
                <li><a href="/slides/">演示文稿</a></li>
                <li><a href="/dart-tips/">Dart 短视频</a></li>

                <li class="divider"></li>
                <li><a href="/community/who-uses-dart.html">谁在使用 Dart</a></li>
              </ul>
            </li>
            <li class="dropdown">
              <a href="/support/" title="Community and Support">
                                              支持
              </a>
            </li>
          </ul>

          <ul class="nav navbar-nav navbar-right">
            <li>
              <form class="navbar-search" action="/search.html" id="cse-search-box">
                <input type="hidden" name="cx" value="011220921317074318178:i4mscbaxtru">
                <input type="hidden" name="ie" value="UTF-8">
                <input type="hidden" name="hl" value="en">
                <input type="search" name="q" class="search-query placeholder-position-fix form-control" id="q" autocomplete="off" placeholder="Search">
              </form>
            </li>
            <li><a target="_blank" href="https://twitter.com/dart_lang" class="btn"><i class="sprite-icon-social-twitter"></i></a></li>
            <li><a target="_blank" href="https://plus.google.com/+dartlang/posts" class="btn"><i class="sprite-icon-social-gplus"></i></a></li>
            <li><a target="_blank" href="http://weibo.com/cndart" class="btn"><i class="sprite-icon-social-weibo"><img src="/imgs/weibo.png"></i></a></li>
          </ul>
        </div><!-- /.nav-collapse -->

      </div><!-- /.container -->
    </div><!-- /.navbar -->

  


<div class="container-page">
  <div class="container">
  	<div class="container sub-page">
      <div class="row">
        <article class="has-permalinks"><div class="col-md-3">
  <div class="bs-sidebar hidden-print affix-top" role="complementary">

<ol class="toc nav bs-sidenav" id="markdown-toc">
  <li><a href="#basic-concepts">Basic concepts</a>    <ol>
      <li><a href="#event-loops-and-queues">Event loops and queues</a></li>
      <li><a href="#darts-single-thread-of-execution">Dart’s single thread of execution</a></li>
      <li><a href="#darts-event-loop-and-queues">Dart’s event loop and queues</a></li>
    </ol>
  </li>
  <li><a href="#tip-chain-futures-to-specify-task-order">Tip: Chain futures to specify task order</a></li>
  <li><a href="#how-to-schedule-a-task">How to schedule a task</a>    <ol>
      <li><a href="#use-the-appropriate-queue-usually-the-event-queue">Use the appropriate queue (usually: the event queue)</a></li>
      <li><a href="#use-isolates-or-workers-if-necessary">Use isolates or workers if necessary</a></li>
    </ol>
  </li>
  <li><a href="#test-your-understanding">Test your understanding</a>    <ol>
      <li><a href="#question-1">Question #1</a></li>
      <li><a href="#question-2">Question #2</a></li>
    </ol>
  </li>
  <li><a href="#summary">Summary</a></li>
</ol>

  </div>
</div>
<div class="col-md-7">
  <p><!-- Start of content -->
	</p>

  <h1 id="the-event-loop-and-dart">The Event Loop and Dart</h1>

  <p><em>Written by Kathy Walrath
<br />
September 2013 (updated October 2013)</em></p>

  <p>Asynchronous code is everywhere in Dart.
Many library functions return Future objects,
and you can register handlers to respond to events such as
mouse clicks, file I/O completions, and timer expirations.</p>

  <p>This article describes Dart’s event loop architecture,
so that you can write better asynchronous code with fewer surprises.
You’ll learn options for scheduling future tasks,
and you’ll be able to predict the order of execution.</p>

  <aside class="alert alert-info">
    <p><strong>Note:</strong>
Everything in this article applies both to Dart apps running natively
(using a Dart VM such as dart or in Dartium)
and to Dart apps that have been compiled to JavaScript
(the output of dart2js).
This article uses the term <em>Dart</em> to differentiate between
Dart apps and software written in other languages.</p>
  </aside>

  <p>Before reading this article,
you should be familiar with the basics of using
<a href="/articles/using-future-based-apis/">Future-based APIs</a>.</p>

  <h2 id="basic-concepts">Basic concepts</h2>

  <p>If you’ve written UI code,
you’re probably familiar with the concepts of
the <em>event loop</em> and the <em>event queue</em>.
They ensure that graphics operations and events
such as mouse clicks are handled one at a time.</p>

  <h3 id="event-loops-and-queues">Event loops and queues</h3>

  <p>An event loop’s job is to take an item from the event queue and handle it,
repeating these two steps for as long as the queue has items.</p>

  <p><img src="images/event-loop.png" alt="events going into a queue, feeding into an event loop" /></p>

  <p>The items in the queue might represent user input,
file I/O notifications, timers, and more.
For example, here’s a picture of the event queue that contains
timer and user input events:</p>

  <p><img src="images/event-loop-example.png" alt="same figure, but with explicit events: 1. key, 2.click, 3. timer, etc." /></p>

  <p>All of that might be familiar from non-Dart languages you know.
Now let’s talk about how it fits into the Dart platform.</p>

  <h3 id="darts-single-thread-of-execution">Dart’s single thread of execution</h3>

  <p>Once a Dart function starts executing,
it continues executing until it exits.
In other words, Dart functions can’t be interrupted by other Dart code.</p>

  <aside class="alert alert-info">
    <p><strong>Note:</strong>
A Dart <em>command-line</em> app can run code in parallel by creating <em>isolates</em>.
(Dart <em>web</em> apps can’t currently create additional isolates,
but they can create <em>workers</em>.)
Isolates don’t share memory;
they’re like separate apps that communicate with each other
by passing messages.
With the exception of code that an app explicitly
runs in additional isolates or workers,
all of an app’s code runs in the app’s <em>main isolate</em>.
For more information, see
<a href="#use-isolates-or-workers-if-necessary">Use isolates or workers if necessary</a>,
later in this article.</p>
  </aside>

  <p>As the following figure shows,
a Dart app starts execution when
its main isolate executes the app’s main() function.
After main() exits,
the main isolate’s thread begins to handle any items on the app’s event queue,
one by one.</p>

  <p><img src="images/event-loop-and-main.png" alt="Add the main isolate executing tasks off the queue: main(), then key event handler, then click event handler, then timer task, etc." /></p>

  <p>Actually, that’s a slight oversimplification.</p>

  <h3 id="darts-event-loop-and-queues">Dart’s event loop and queues</h3>

  <p>A Dart app has a single event loop with <em>two</em> queues—the
<em>event queue</em> and the <em>microtask queue</em>.</p>

  <p>The <strong>event queue</strong> contains all outside events:
I/O, mouse events, drawing events, timers,
messages between Dart isolates, and so on.</p>

  <p>The <strong>microtask queue</strong> is necessary because
event-handling code sometimes needs to complete a task later,
but before returning control to the event loop.
For example, when an observable object changes,
it groups several mutation changes together
and reports them asychronously.
The microtask queue allows the observable object
to report these mutation changes
before the DOM can show the inconsistent state.</p>

  <p>The event queue contains events both from Dart and
from elsewhere in the system.
Currently, the microtask queue contains only entries originating
from within Dart code,
but we expect the web implementation to plug into
the browser microtask queue.
(For the latest status, see
<a href="https://code.google.com/p/dart/issues/detail?id=13433">dartbug.com/13433</a>.)</p>

  <p>As the following figure shows,
when main() exits,
the event loop starts its work.
First, it executes any microtasks, in FIFO order.
Then it dequeues and handles the first item on the event queue.
Then it repeats the cycle: execute all microtasks,
and then handle the next item on the event queue.
Once both queues are empty and no more events are expected,
the app’s <em>embedder</em> (such as the browser or a test framework)
can dispose of the app.</p>

  <aside class="alert alert-info">
    <p><strong>Note:</strong>
If a web app’s user closes its window,
then the web app might exit before its event queue is empty.</p>
  </aside>

  <p><img src="images/both-queues.png" alt="flowchart: main() -&gt; microtasks -&gt; next event -&gt; microtasks -&gt; ..." /></p>

  <aside class="alert alert-warning">
    <p><strong>Important:</strong>
While the event loop is executing tasks from the microtask queue,
the event queue is stuck:
the app can’t
draw graphics, handle mouse clicks, react to I/O, and so on.</p>
  </aside>

  <p>Although you can predict the <em>order</em> of task execution,
you can’t predict exactly <em>when</em> an event loop will take a task off the queue.
The Dart event handling system is based on a single-threaded cycle;
it isn’t based on ticks or any other kind of time measurement.
For example, when you create a delayed task,
an event is enqueued at the time you specify.
However, that event can’t be handled until
everything before it in the event queue
(as well as every single task in the microtask queue) is handled.</p>

  <h2 id="tip-chain-futures-to-specify-task-order">Tip: Chain futures to specify task order</h2>

  <p>If your code has dependencies, make them explicit.
Explicit dependencies help other developers to understand your code,
and they make your program more resistant to code refactoring.</p>

  <p>Here’s an example of the <em>wrong</em> way to code:</p>

  <pre class="prettyprint lang-dart">// BAD because of no explicit dependency between setting and using
// the variable.
future.then(...set an important variable...);
Timer.run(() {...use the important variable...});</pre>

  <p>Instead, write code like this:</p>

  <pre class="prettyprint lang-dart">// BETTER because the dependency is explicit.
future.then(...set an important variable...)
  .then((_) {...use the important variable...});</pre>

  <p>The better code uses then() to specify that
the variable must be set before it can be used.
(You can use whenComplete() instead of then()
if you want the code to execute even if an error occurs.)</p>

  <p>If using the variable takes time and can be done later,
consider putting that code in a new Future:</p>

  <pre class="prettyprint lang-dart">// MAYBE EVEN BETTER: Explicit dependency plus delayed execution.
future.then(...set an important variable...)
  .then((_) {new Future(() {...use the important variable...})});</pre>

  <p>Using a new Future gives the event loop a chance to
process other events from the event queue.
The next section gives details on scheduling code to run later.</p>

  <h2 id="how-to-schedule-a-task">How to schedule a task</h2>

  <p>When you need to specify some code to be executed later,
you can use the following APIs provided by the dart:async library:</p>

  <ol>
    <li>The <strong>Future</strong> class,
which adds an item to the end of the <strong>event queue</strong>.</li>
    <li>The top-level <strong>scheduleMicrotask()</strong> function,
which adds an item to the end of the <strong>microtask queue</strong>.</li>
  </ol>

  <aside class="alert alert-info">
    <p><strong>Note:</strong>
The <strong>scheduleMicrotask()</strong> function used to be named <strong>runAsync()</strong>.
(See the <a href="https://groups.google.com/a/dartlang.org/forum/#!msg/misc/7sAIhWXfIKQ/PzYJy1QqtWUJ">announcement</a>.)</p>
  </aside>

  <p>Examples of using these APIs are in the next section under
<a href="#event-queue-new-future">Event queue: new Future()</a> and
<a href="#microtask-queue">Microtask queue: scheduleMicrotask()</a>.</p>

  <h3 id="use-the-appropriate-queue-usually-the-event-queue">Use the appropriate queue (usually: the event queue)</h3>

  <p>Whenever possible, schedule tasks on the event queue, with Future.
Using the event queue helps keep the the microtask queue short,
reducing the likelihood of the microtask queue starving the event queue.</p>

  <p>If a task absolutely must complete before
any items from the event queue are handled,
then you should usually just execute the function immediately.
If you can’t, then use scheduleMicrotask() to
add an item to the microtask queue.
For example, in a web app use a microtask to
avoid prematurely releasing a js-interop proxy or
ending an IndexedDB transaction or event handler.</p>

  <p><img src="images/scheduling-tasks.png" alt="shows chain of event handler execution, with tasks added using Future and scheduleMicrotask()." /></p>

  <h4 class="no_toc" id="event-queue-new-future">Event queue: new Future()</h4>

  <p>To schedule a task on the event queue,
use <code>new Future()</code> or <code>new Future.delayed()</code>.
These are two of the
<a href="http://api.dartlang.org/dart_async/Future.html">Future</a>
constructors defined in the dart:async library.</p>

  <aside class="alert alert-info">
    <p><strong>Note:</strong>
You can also use
<a href="http://api.dartlang.org/dart_async/Timer.html">Timer</a> to schedule tasks,
but if any uncaught exceptions occur in the task,
your app will exit.
Instead, we recommend Future,
which is built on top of Timer and adds features such as
detecting task completion and responding to errors.</p>
  </aside>

  <p>To immediately put an item on the event queue, use <code>new Future()</code>:</p>

  <pre class="prettyprint lang-dart">// Adds a task to the event queue.
new Future(() {
  // ...code goes here...
});</pre>

  <p>You can add a call to <code>then()</code> or <code>whenComplete()</code> to
execute some code immediately after the new Future completes.
For example, the following code prints “42” when
the new Future’s task is dequeued:</p>

  <pre class="prettyprint lang-dart">new Future(() =&gt; 21)
    .then((v) =&gt; v*2)
    .then((v) =&gt; print(v));</pre>

  <p>To enqueue an item after some time elapses, use <code>new Future.delayed()</code>:</p>

  <pre class="prettyprint lang-dart">// After a one-second delay, adds a task to the event queue.
new Future.delayed(const Duration(seconds:1), () {
  // ...code goes here...
});</pre>

  <p>Although the preceding example adds the task to the event queue
after one second,
that task can’t execute until the main isolate is idle,
the microtask queue is empty,
and previously enqueued entries in the event queue are gone.
For example, if the main() function or an event handler are
running an expensive computation,
the task can’t execute until after that computation completes.
In that case, the delay might be much more than one second.</p>

  <aside class="alert alert-info">
    <p><strong>Tip:</strong>
If you’re drawing frames for animation in a web app,
don’t use a Future (or Timer or Stream).
Instead, use
<a href="http://api.dartlang.org/dart_html/Window.html#animationFrame">animationFrame</a>,
which is the Dart interface to
<a href="http://www.html5rocks.com/en/tutorials/speed/animations/">requestAnimationFrame</a>.</p>
  </aside>

  <p>Fun facts about Future:</p>

  <ol>
    <li>The function that you pass into Future’s <strong>then()</strong> method
executes immediately when the Future completes.
(The function isn’t enqueued, it’s just called.)</li>
    <li>If a Future is <em>already complete</em> before <strong>then()</strong> is invoked on it,
then a task is added to the <em>microtask queue</em>,
and <em>that</em> task executes the function passed into then().</li>
    <li>The <strong>Future()</strong> and <strong>Future.delayed()</strong> constructors
don’t complete immediately;
they add an item to the event queue.</li>
    <li>The <strong>Future.value()</strong> constructor completes in a microtask,
similar to #2.</li>
    <li>The <strong>Future.sync()</strong> constructor executes its function argument immediately
and (unless that function returns a Future)
completes in a microtask, similar to #2.</li>
  </ol>

  <h4 class="no_toc" id="microtask-queue-schedulemicrotask">Microtask queue: scheduleMicrotask()</h4>

  <p>The dart:async library defines scheduleMicrotask() as a top-level function.
You can call scheduleMicrotask() like this:</p>

  <pre class="prettyprint lang-dart">scheduleMicrotask(() {
  // ...code goes here...
});</pre>

  <p>Due to bugs <a href="https://code.google.com/p/dart/issues/detail?id=9001">9001</a>
and <a href="https://code.google.com/p/dart/issues/detail?id=9002">9002</a>,
the first call to scheduleMicrotask() schedules a task on the event queue;
this task creates the microtask queue and
enqueues the function specified to scheduleMicrotask().
As long as the microtask queue has at least one entry,
subsequent calls to scheduleMicrotask() correctly add to the microtask queue.
Once the microtask queue is empty,
it must be created again the next time scheduleMicrotask() is called.</p>

  <p>The upshot of these bugs:
The first task that you schedule with scheduleMicrotask() seems
like it’s on the event queue.</p>

  <p>A workaround is to put your first call to scheduleMicrotask() before
your first call to new Future().
This creates the microtask queue before
executing other tasks on the event queue.
However, it doesn’t stop external events from being added to the event queue.
It also doesn’t help when you have a delayed task.</p>

  <p>Another way to add a task to the microtask queue is
to invoke then() on a Future that’s already complete.
See the previous section for more information.</p>

  <h3 id="use-isolates-or-workers-if-necessary">Use isolates or workers if necessary</h3>

  <p>What if you have a compute-intensive task to run?
To keep your app responsive,
you should put the task into its own isolate or worker.
Isolates might run in a separate process or thread,
depending on the Dart implementation.
In 1.0 we don’t expect web apps to support isolates or Dart-language workers.
However, you can use the
<a href="http://api.dartlang.org/dart_html/Worker.html">dart:html Worker class</a>
to add a JavaScript worker to a Dart web app.</p>

  <p>How many isolates should you use? For compute-intensive tasks,
you should generally use as many isolates as you expect to have CPUs available.
Any additional isolates are just wasted if they’re purely computational.
However, if the isolates perform asynchronous calls—to perform I/O,
for example—then they won’t spend much time on the CPUs,
so having more isolates than CPUs makes sense.</p>

  <p>You can also use more isolates than CPUs
if that’s a good architecture for your app.
For example, you might use a separate isolate
for each piece of functionality,
or when you need to ensure that data isn’t shared.</p>

  <p>See <a href="/docs/dart-up-and-running/contents/ch03.html#ch03-dartisolate---concurrency-with-isolates">dart:isolate - Concurrency with Isolates</a>
for more information and examples of using isolates.</p>

  <h2 id="test-your-understanding">Test your understanding</h2>

  <p>Now that you’ve read all about scheduling tasks,
let’s test your understanding.</p>

  <p>Remember, you shouldn’t depend on Dart’s event queue implementation
to specify task order.
The implementation might change,
and Future’s then() and whenComplete() methods are a better alternative.
Still, won’t you feel smart if you can answer these questions correctly?</p>

  <h3 id="question-1">Question #1</h3>

  <p>What does this sample print out?</p>

  <pre class="prettyprint lang-dart">import 'dart:async';
main() {
  print('main #1 of 2');
  scheduleMicrotask(() =&gt; print('microtask #1 of 2'));

  new Future.delayed(new Duration(seconds:1),
                     () =&gt; print('future #1 (delayed)'));
  new Future(() =&gt; print('future #2 of 3'));
  new Future(() =&gt; print('future #3 of 3'));

  scheduleMicrotask(() =&gt; print('microtask #2 of 2'));

  print('main #2 of 2');
}</pre>

  <p>The answer:</p>

  <pre>
main #1 of 2
main #2 of 2
microtask #1 of 2
microtask #2 of 2
future #2 of 3
future #3 of 3
future #1 (delayed)
</pre>

  <p>That order should be what you expected,
since the example’s code executes in three batches:</p>

  <ol>
    <li>code in the main() function</li>
    <li>tasks in the microtask queue (scheduleMicrotask())</li>
    <li>tasks in the event queue (new Future() or new Future.delayed())</li>
  </ol>

  <p>Keep in mind that all the calls in the main() function execute synchronously,
start to finish.
First main() calls print(), then scheduleMicrotask(),
then new Future.delayed(), then new Future(), and so on.
Only the callbacks—the code in the closure bodies specified as
arguments to scheduleMicrotask(), new Future.delayed(), and
new Future()—execute at a later time.</p>

  <aside class="alert alert-info">
    <p><strong>Note:</strong>
Currently, if you comment out the first call to scheduleMicrotask(),
then the callbacks for futures #2 and #3 execute before microtask #2.
This is due to bugs 9001 and 9002, as discussed in
<a href="#microtask-queue">Microtask queue: scheduleMicrotask()</a>.</p>
  </aside>

  <h3 id="question-2">Question #2</h3>

  <p>Here’s a more complex example.
If you can correctly predict the output of this code,
you get a gold star.</p>

  <pre class="prettyprint lang-dart">import 'dart:async';
main() {
  print('main #1 of 2');
  scheduleMicrotask(() =&gt; print('microtask #1 of 3'));

  new Future.delayed(new Duration(seconds:1),
      () =&gt; print('future #1 (delayed)'));

  new Future(() =&gt; print('future #2 of 4'))
      .then((_) =&gt; print('future #2a'))
      .then((_) {
        print('future #2b');
        scheduleMicrotask(() =&gt; print('microtask #0 (from future #2b)'));
      })
      .then((_) =&gt; print('future #2c'));

  scheduleMicrotask(() =&gt; print('microtask #2 of 3'));

  new Future(() =&gt; print('future #3 of 4'))
      .then((_) =&gt; new Future(
                   () =&gt; print('future #3a (a new future)')))
      .then((_) =&gt; print('future #3b'));

  new Future(() =&gt; print('future #4 of 4'));
  scheduleMicrotask(() =&gt; print('microtask #3 of 3'));
  print('main #2 of 2');
}</pre>

  <p>The output, assuming bugs 9001/9002 aren’t fixed:</p>

  <pre>
main #1 of 2
main #2 of 2
microtask #1 of 3
microtask #2 of 3
microtask #3 of 3
future #2 of 4
future #2a
future #2b
future #2c
future #3 of 4
future #4 of 4
microtask #0 (from future #2b)
future #3a (a new future)
future #3b
future #1 (delayed)
</pre>

  <aside class="alert alert-info">
    <p><strong>Note:</strong>
Due to bugs 9001/9002,
microtask #0 executes after future #4;
it should instead execute before future #3.
This bug shows up because by the time future #2b executes,
no microtasks are queued,
so microtask #0 results in a new task on the event queue,
which creates a new microtask queue.
This microtask queue contains microtask #0.
If you comment out microtask #1,
then the microtasks all appear together just after future #2c,
and before future #3.</p>
  </aside>

  <p>Like before, the main() function executes,
and then everything on the microtask queue,
and then tasks on the event queue.
Here are a few interesting points:</p>

  <ul>
    <li>When the then() callback for future 3 calls new Future(),
it creates a new task (#3a) that’s added to the end of the event queue.</li>
    <li>All the then() callbacks execute as soon as
the Future they’re invoked on completes.
Thus, future 2, 2a, 2b, and 2c execute all in one go,
before control returns to the embedder.
Similarly, future 3a and 3b execute all in one go.</li>
    <li>If you change the 3a code from
<code>then((_) =&gt; new Future(...))</code> to
<code>then((_) {new Future(...); })</code>,
then “future #3b” appears earlier
(after future #3, instead of future #3a).
The reason is that returning a Future from your callback
is how you get then() (which itself returns a new Future)
to <em>chain</em> those two Futures together,
so that the Future returned by then() completes
when the Future returned by the callback completes.
See the <a href="http://api.dartlang.org/docs/releases/latest/dart_async/Future.html#then">then() reference</a>
for more information.</li>
  </ul>

  <h4 class="no_toc" id="annotated-sample-and-output">Annotated sample and output</h4>

  <p>Here are some figures that might clarify the answer to question #2.
First, here’s the annotated program source:</p>

  <p><img src="images/test-annotated.png" alt="Lines that schedule a microtask are gold; lines that schedule an event are blue" /></p>

  <p>And here’s what the queues and output look like at various points in time,
assuming no external events come in:</p>

  <p><img src="images/test-queue-output.png" alt="3 columns: Time, Output, Queues" /></p>

  <h2 id="summary">Summary</h2>

  <p>You should now understand Dart’s event loops and how to schedule tasks.
Here are some of the major concepts of event loops in Dart:</p>

  <ul>
    <li>A Dart app’s event loop executes tasks from two queues:
the event queue and the microtask queue.</li>
    <li>The event queue has entries from both Dart
(futures, timers, isolate messages, and so on)
and the system (user actions, I/O, and so on).</li>
    <li>Currently, the microtask queue has entries only from Dart,
but we expect it to be merged with the browser microtask queue.</li>
    <li>The event loop empties the microtask queue before
dequeuing and handling the next item on the event queue.</li>
    <li>Once both queues are empty, the app has completed its work
and (depending on its embedder) can exit.</li>
    <li>The main() function and all items from the microtask and event queues
run on the Dart app’s main isolate.</li>
  </ul>

  <p>When you schedule a task, follow these rules:</p>

  <ul>
    <li>If possible, put it on the event queue
(using new Future() or new Future.delayed()).</li>
    <li>Use Future’s then() or whenComplete() method to specify task order.</li>
    <li>To avoid starving the event loop,
keep the microtask queue as short as possible.</li>
    <li>To keep your app responsive,
avoid compute-intensive tasks on either event loop.</li>
    <li>To perform compute-intensive tasks,
create additional isolates or workers.</li>
  </ul>

  <p>As you write asynchronous code, you might find these resources helpful:</p>

  <ul>
    <li><a href="/articles/using-future-based-apis/">Using Future Based APIs</a></li>
    <li><a href="/articles/futures-and-error-handling/">Futures and Error Handling</a></li>
    <li><a href="/docs/dart-up-and-running/contents/ch03.html#ch03-asynchronous-programming">dart:async - Asynchronous Programming</a> section of the library tour</li>
    <li><a href="http://api.dartlang.org/dart_async.html">dart:async API reference</a></li>
  </ul>
</div>

    	  </div> <!-- End of content from toc.html -->
        </article>
	  </div>

	
	<ul class="pager">
	  <li><a href="/articles/">关于 Dart 的更多文章 <i class="glyphicon glyphicon-chevron-up"></i></a></li>
	 </ul>
	 

	</div>
  </div>
</div>

  <footer class="footer container-full">
    <div class="container">
      <div class="row">
        <div class="col-md-5">
          <h3>一种用于创建可扩展 web 应用程序的语言、工具和代码库</h3>
          <p>Dart 是一个 <a href="https://code.google.com/p/dart/">开源项目</a>，由  Google 和其他人员参与。</p>
          <p class="sm">除非注明，该页面内容使用 the Creative Commons Attribution 3.0 License 发布，示例代码使用  BSD License 发布。</p>
          <!-- 
          <p><a class="saelogo" href="http://sae.sina.com.cn/activity/invite/15649/weibo" target="_blank"><img src="http://static.sae.sina.com.cn/image/poweredby/poweredby.png" title="Powered by Sina App Engine"></a></p>     	
          -->
        </div>
        <div class="col-md-2 col-md-offset-1">
          <h4>受欢迎的文章</h4>
          <ul>
            <li><a href="/polymer-dart/?utm_source=site&amp;utm_medium=footer&amp;utm_campaign=homepage">Polymer.dart</a></li>
            <li><a href="/performance/">性能</a></li>
            <li><a href="/docs/dart-up-and-running/contents/ch02.html?utm_source=site&amp;utm_medium=footer&amp;utm_campaign=homepage">语言概览</a> &amp;
            <a href="/docs/dart-up-and-running/contents/ch03.html?utm_source=site&amp;utm_medium=footer&amp;utm_campaign=homepage">代码库概览</a></li>
            <li><a href="/samples/?utm_source=site&amp;utm_medium=footer&amp;utm_campaign=homepage">示例代码</a></li>
            <li><a href="/docs/tutorials/?utm_source=site&amp;utm_medium=footer&amp;utm_campaign=homepage">教程</a> &amp;
                <a href="/codelabs/darrrt/?utm_source=site&amp;utm_medium=footer&amp;utm_campaign=homepage">代码实验室</a></li>
          </ul>
        </div>
        <div class="col-md-2">
          <h4>资源</h4>
          <ul>
            <li><a href="http://pub.dartlang.org/">Pub packages</a></li>
            <li><a href="/docs/synonyms/">和其他语言的相同点</a></li>
            <li><a href="http://code.google.com/p/dart/issues/list">Dart bugs and feature requests</a></li>
          </ul>
        </div>
        <div class="col-md-2">
          <h4>社区</h4>
          <ul>
            <li><a href="/support/">邮件列表</a></li>
            <li><a href="http://forum.dartlang.cc">中文社区</a></li>
            <li><a href="http://weibo.com/cndart">中文微博</a></li>
            <li><a href="https://plus.google.com/communities/114566943291919232850">G+ 社区</a></li>
            <li><a href="https://plus.google.com/+dartlang/posts">G+ 新闻发布频道</a></li>
            <li><a href="http://stackoverflow.com/questions/tagged/dart">Stack Overflow</a></li>
          </ul>
        </div>
      </div>
    </div>
  </footer> <!-- End footer -->

<script type='text/javascript' src='/js/jquery.js'></script>
<script type='text/javascript' src='/js/bootstrap.min.js'></script>
<script type='text/javascript' src='/js/prettify.js'></script>
<script type='text/javascript' src='/js/lang-dart.js'></script>
<script type='text/javascript' src='/js/lang-yaml.js'></script>
<script type='text/javascript' src='/js/scripts.js'></script>




<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F76b2695e71e6cec6e6af036d76afa367' type='text/javascript'%3E%3C/script%3E"));
</script>

<!-- Baidu Button BEGIN -->
<script type="text/javascript" id="bdshare_js" data="type=slide&amp;img=1&amp;pos=left&amp;uid=590574" ></script>
<script type="text/javascript" id="bdshell_js"></script>
<script type="text/javascript">
var bds_config={"bdTop":367};
document.getElementById("bdshell_js").src = "http://bdimg.share.baidu.com/static/js/shell_v2.js?cdnversion=" + Math.ceil(new Date()/3600000);
</script>
<!-- Baidu Button END -->
</body>
</html>

