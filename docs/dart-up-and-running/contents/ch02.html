<!DOCTYPE html>
<html lang="en" itemscope itemtype="http://schema.org/Product" xmlns:wb="http://open.weibo.com/wb">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  
  <title>Chapter 2. Dart 语言概览 from Dart: Up and Running | Dart: 用于创建结构化的web应用</title>
  <meta property="wb:webmaster" content="a984f6440858ee44" />
  <meta property="twitter:account_id" content="376585411" />
  <meta itemprop="name" content="Chapter 2. Dart 语言概览 from Dart: Up and Running | Dart: 用于创建结构化的web应用">
  
  <meta itemprop="image" content="https://www.dartlang.org/imgs/dart-logo-wordmark-1200w.png">
  
  <meta itemprop="description" content="Read Chapter 2. Dart 语言概览 of Dart: Up and Running, published by O'Reilly.">


  <link rel='stylesheet' type='text/css' href='/css/bootstrap.min.css'>
<link rel='stylesheet' type='text/css' href='/css/dart-style.css'>
<link rel='stylesheet' type='text/css' href='/css/prettify.css'>

  
    <link href="//fonts.googleapis.com/css?family=Montserrat:400,700|Roboto:300,400" rel="stylesheet">

	
	
	
	<link rel="alternate" type="application/atom+xml" href="http://dartnews.sinaapp.com/?feed=atom" title="Atom feed">
  <!-- 
  <link href="https://plus.google.com/109866369054280216564" rel="publisher">
  -->
  <link href="http://weibo.com/cndart" rel="publisher">

  <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!--[if lt IE 9]>
    <script src="js/html5shiv.js"></script>
    <script src="js/respond.min.js"></script>
  <![endif]-->

  <!-- 
<script type="text/javascript">

  //var _gaq = _gaq || [];
 // _gaq.push(['_setAccount', 'UA-26406144-4']);
  //_gaq.push(['_setDomainName', 'dartlang.org']);
  //_gaq.push(['_setSiteSpeedSampleRate', 50]);
  //_gaq.push(['_trackPageview']);

 // (function() {
   // var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
   // ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
   // var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
 // })();

</script>
-->


  <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
</head>
<body onload="prettyPrint()">
    <div class="navbar navbar-fixed-top navbar-inverse" role="navigation">
      <div class="container">
        
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="/"><i class="sprite-icon-dart-logo"></i></a>
        </div>

        <div class="collapse navbar-collapse">
          <ul class="nav navbar-nav">
           <li class="dropdown">
              <a href="/codelabs/darrrt/" title="Learn Dart in this short code lab.">
                                                       入门
              </a>
            </li>
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">
                                                文档
              </a>
              <ul class="dropdown-menu">
                <i class="sprite-icon-dd-tip"></i>
                <li><a href="/docs/tutorials/">教程</a></li>
                <li class="divider"></li>
                 
                <li><a href="/docs/">开发者指南</a></li>
                <li><a href="http://api.dartlang.org">API 参考</a></li>
                <li><a href="/docs/spec/">语言规范</a></li>

                <li class="divider"></li>
                <li><a href="/docs/dart-up-and-running/">Dart: Up and Running</a></li>
                <li><a href="/books/">更多图书</a></li>

                <li class="divider"></li>
                <li><a href="/articles/">文章</a></li>
                <li><a href="/support/faq.html">FAQ</a></li>
              </ul>
            </li>
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">
                                       工具
              </a>
              <ul class="dropdown-menu">
                <i class="sprite-icon-dd-tip"></i>
                <li><a href="/docs/dart-up-and-running/contents/ch04-tools-dart2js.html">dart2js</a>
                </li><li><a href="/tools/editor/">Dart Editor</a></li>
                <li><a href="http://pub.dartlang.org/">Pub Package Manager</a></li>
                <li><a href="/tools/">更多工具</a></li>
              </ul>
            </li>
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">
                                                     资源
              </a>
              <ul class="dropdown-menu">
                <i class="sprite-icon-dd-tip"></i>
                <li><a href="/samples/">示例代码</a></li>
                <li><a href="http://synonym.dartlang.org/">Translations from Dart</a></li>

                <li class="divider"></li>
                <li><a href="/slides/">演示文稿</a></li>
                <li><a href="/dart-tips/">Dart 短视频</a></li>

                <li class="divider"></li>
                <li><a href="/performance/">性能</a></li>
                <li class="divider"></li>
                <li><a href="http://code.google.com/p/dart/issues/list">Bugs and Feature Requests</a></li>
              </ul>
            </li>
            <li class="dropdown">
              <a href="/support/" title="Community and Support">
                                              社区
              </a>
            </li>
          </ul>

          <ul class="nav navbar-nav navbar-right">
            <li>
              <form class="navbar-search" action="/search.html" id="cse-search-box">
                <input type="hidden" name="cx" value="011220921317074318178:i4mscbaxtru">
                <input type="hidden" name="ie" value="UTF-8">
                <input type="hidden" name="hl" value="en">
                <input type="search" name="q" class="search-query placeholder-position-fix form-control" id="q" autocomplete="off" placeholder="Search">
              </form>
            </li>
            <li><a target="_blank" href="https://twitter.com/dart_lang" class="btn"><i class="sprite-icon-social-twitter"></i></a></li>
            <li><a target="_blank" href="https://plus.google.com/+dartlang/posts" class="btn"><i class="sprite-icon-social-gplus"></i></a></li>
            <li><a target="_blank" href="http://weibo.com/cndart" class="btn"><i class="sprite-icon-social-weibo"><img src="/imgs/weibo.png"></i></a></li>
          </ul>
        </div><!-- /.nav-collapse -->

      </div><!-- /.container -->
    </div><!-- /.navbar -->

  


<div class="container-page">
  <div class="container">
    <div class="container sub-page">

      <div id="book-header">
      An excerpt from <a href="/docs/dart-up-and-running/"><em>Dart: Up and Running</em></a>
      </div>

      <article class="up-and-running-contents">
        <div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 2. Dart 语言概览</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch01.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ch03.html">Next</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="ch02"></a>Chapter 2. Dart 语言概览</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="ch02.html#main-print">一个基本的 Dart 程序</a></span></dt><dt><span class="sect1"><a href="ch02.html#ch02-concepts">重要的概念</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch02.html#ch02-keywords">关键字</a></span></dt><dt><span class="sect2"><a href="ch02.html#ch02-runtime-modes">运行时模式</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch02.html#variables">变量</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch02.html#variables-default-value">默认值</a></span></dt><dt><span class="sect2"><a href="ch02.html#variables-optional-types">可选类型</a></span></dt><dt><span class="sect2"><a href="ch02.html#ch02-final-const">Final 和 Const</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch02.html#built-in-types">内置类型</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch02.html#numbers">Numbers</a></span></dt><dt><span class="sect2"><a href="ch02.html#strings">Strings</a></span></dt><dt><span class="sect2"><a href="ch02.html#booleans">Booleans</a></span></dt><dt><span class="sect2"><a href="ch02.html#lists">Lists</a></span></dt><dt><span class="sect2"><a href="ch02.html#maps">Maps</a></span></dt><dt><span class="sect2"><a href="ch02.html#ch02-symbols">Symbols（符号）</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch02.html#functions">Functions（方法）</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch02.html#functions-optional-parameters">可选参数</a></span></dt><dt><span class="sect2"><a href="ch02.html#ch02-main"> main() 方法</a></span></dt><dt><span class="sect2"><a href="ch02.html#ch02-functions-first-class">（方法作为一等对象）Functions as First-Class Objects</a></span></dt><dt><span class="sect2"><a href="ch02.html#ch02-lexical-scope">（语法作用域）Lexical Scope</a></span></dt><dt><span class="sect2"><a href="ch02.html#ch02-functions-lexical-closures">（语法闭包）Lexical Closures</a></span></dt><dt><span class="sect2"><a href="ch02.html#ch02-function-equality">判断函数相等</a></span></dt><dt><span class="sect2"><a href="ch02.html#ch02-functions-return-values">返回值</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch02.html#operators">操作符</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch02.html#op-arithmetic">算术操作符</a></span></dt><dt><span class="sect2"><a href="ch02.html#op-equality">关系和相等操作符</a></span></dt><dt><span class="sect2"><a href="ch02.html#ch02-op-type-test">类型测试操作符</a></span></dt><dt><span class="sect2"><a href="ch02.html#op-assign">赋值操作符</a></span></dt><dt><span class="sect2"><a href="ch02.html#op-logical">逻辑操作符（逻辑运算符）</a></span></dt><dt><span class="sect2"><a href="ch02.html#op-bit">位和移位操作符</a></span></dt><dt><span class="sect2"><a href="ch02.html#op-other">其他操作符</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch02.html#control-flow-statements">控制流程语句</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch02.html#if-else">If 和 Else</a></span></dt><dt><span class="sect2"><a href="ch02.html#for-loops">For 循环</a></span></dt><dt><span class="sect2"><a href="ch02.html#while">While 和 Do-While</a></span></dt><dt><span class="sect2"><a href="ch02.html#break">Break 和 Continue</a></span></dt><dt><span class="sect2"><a href="ch02.html#switch">Switch 和 Case</a></span></dt><dt><span class="sect2"><a href="ch02.html#assert">Assert（断言）</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch02.html#exceptions">Exceptions（异常）</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch02.html#ch02-exceptions-throw">Throw</a></span></dt><dt><span class="sect2"><a href="ch02.html#ch02-exceptions-catch">Catch</a></span></dt><dt><span class="sect2"><a href="ch02.html#ch02-exceptions-finally">Finally</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch02.html#classes">Classes</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch02.html#ch02-instance-variables">实例变量</a></span></dt><dt><span class="sect2"><a href="ch02.html#ch02-constructors">构造函数</a></span></dt><dt><span class="sect2"><a href="ch02.html#ch02-methods">函数</a></span></dt><dt><span class="sect2"><a href="ch02.html#ch02-class-abstract">抽象类</a></span></dt><dt><span class="sect2"><a href="ch02.html#ch02-implicit-interfaces">隐式接口（Implicit Interfaces）</a></span></dt><dt><span class="sect2"><a href="ch02.html#ch02-class-extend">继承一个类</a></span></dt><dt><span class="sect2"><a href="ch02.html#ch02-mixins">在类中添加功能： Mixins（混入）</a></span></dt><dt><span class="sect2"><a href="ch02.html#ch02-class-vars-and-methods">类（静态）变量和函数</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch02.html#generics">Generics（泛型）</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch02.html#ch02-generics-why">为何使用泛型？</a></span></dt><dt><span class="sect2"><a href="ch02.html#generics-literals">使用集合字面量</a></span></dt><dt><span class="sect2"><a href="ch02.html#generics-constructors">使用泛型构造函数</a></span></dt><dt><span class="sect2"><a href="ch02.html#generics-collections">泛型集合和类型</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch02.html#libraries">库和可见性</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch02.html#libraries-import">使用库</a></span></dt><dt><span class="sect2"><a href="ch02.html#libraries-implementing">实现一个库</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch02.html#isolates">Isolates</a></span></dt><dt><span class="sect1"><a href="ch02.html#typedefs">Typedefs</a></span></dt><dt><span class="sect1"><a href="ch02.html#ch02-metadata">Metadata（元数据）</a></span></dt><dt><span class="sect1"><a href="ch02.html#comments">注释</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch02.html#ch02-comments-single-line">单行注释</a></span></dt><dt><span class="sect2"><a href="ch02.html#ch02-comments-multi-line">多行注释</a></span></dt><dt><span class="sect2"><a href="ch02.html#comments-doc">文档注释</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch02.html#ch02-summary">总结</a></span></dt></dl></div><p>本章介绍 Dart 语言的主要特性 -- 变量、操作符、类和库 等。
      本章假设你具有其他编程语言的背景知识。</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>你可以按照 <a class="xref" href="ch01.html#ch01-editor" title="开始使用 Dart">the section called “开始使用 Dart”</a> 中介绍的方法创建个命令行应用来
        动手演示这些特性。</p></div><p>如果你想了解某个特性的详细信息，可以参考
       <a class="ulink" href="http://www.dartlang.cc/docs/spec/" target="_top">Dart
  语言规范</a> 。</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="main-print"></a>一个基本的 Dart 程序</h2></div></div></div><p>下面的代码使用很多 Dart 语言的基本特性：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>// 定义一个方法
printNumber(num aNumber) {
  print('The number is $aNumber.'); // 在控制台打印信息
}

// 应用开始执行的入口
main() {
  var number = 42;           // 定义并初始化一个变量
  printNumber(number);       // 调用一个方法
}</pre><p>下面是上面的代码使用到的可以应用其他（几乎）所有 Dart 应用的
        特性：</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">// <em class="replaceable"><code>这是一个注释。
            </code></em></code></span></dt><dd><p>使用 // 表明后面的文字为注释。
          另外还可以用 /* ... */。详细信息，参考 <a class="xref" href="ch02.html#comments" title="注释">the section called “注释”</a>。</p></dd><dt><span class="term"><code class="literal">num</code></span></dt><dd><p>一种类型。其他内建的类型有 String、int、和 bool。
          </p></dd><dt><span class="term"><code class="literal">42</code></span></dt><dd><p>一个数字 <em class="firstterm">literal（字面量）</em>。
              字面量是一种编译期常量。</p></dd><dt><span class="term"><code class="literal">print()</code></span></dt><dd><p>一种打印结果的助手方法。</p></dd><dt><span class="term"><code class="literal">'...'</code> (或者 <code class="literal">"..."</code>)</span></dt><dd><p>声明 String 的 字面量。</p></dd><dt><span class="term"><code class="literal">$<em class="replaceable"><code>variableName</code></em></code> (或者
        <code class="literal">${<em class="replaceable"><code>expression</code></em></code><code class="literal">}</code>)</span></dt><dd><p>字符串插值（String interpolation）：在一个字符串字面量中包含
              一个变量或者表达式，最终该变量或者表达式的值将替换在字符串中。详细信息请参考：
           <a class="xref" href="ch02.html#strings" title="Strings">the section called “Strings”</a>。</p></dd><dt><span class="term"><code class="literal">main()</code></span></dt><dd><p>Dart 程序<span class="emphasis"><em>必需的</em></span>顶级入口函数。
              Dart 程序从该函数开始执行。 详细信息请参考： <a class="xref" href="ch02.html#ch02-main" title="main() 方法">the section called “ main() 方法”</a>。</p></dd><dt><span class="term"><code class="literal">var</code></span></dt><dd><p>一种定义无类型变量的方法。</p></dd></dl></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>我们的代码遵守 <a class="ulink" href="http://www.dartlang.cc/articles/style-guide/" target="_top">Dart 风格指南
      </a> 中介绍的格式。例如，我们用了两个空格的缩进。</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ch02-concepts"></a>重要的概念</h2></div></div></div><p>在学习 Dart 语言的时候，请记住如下概念：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>变量引用的任意内容都是一个
        <span class="emphasis"><em>对象（object）</em></span>，任意对象都是一个
        <span class="emphasis"><em>类（class）</em></span> 的实例。甚至 数字（ numbers）、方法（ functions）、 和<code class="literal">null</code> 都是对象。所有的对象都从
         <a class="ulink" href="http://api.dartlang.org/dart_core/Object.html" target="_top">Object</a>
        类继承下来。</p></li><li class="listitem"><p>指定静态类型（例如前面示例的  <code class="literal">num</code> ） 明确你的意图，并且可以使用
        工具的静态分析工具，但是类型是可选的。（在调试代码的时候，你可能已经注意到了，虽然你指定了静态类型，但是在调试的时候
        该变量并没有指定具体的类型，而是使用了一个特殊的类型： <code class="literal">dynamic</code>）。</p></li><li class="listitem"><p>Dart 在运行代码之前先解析代码。 你可以给 Dart 提供
            一些扑捉错误和帮助提高代码运行效率的建议，例如使用 类型、或者使用编译期常量。</p></li><li class="listitem"><p>Dart 支持顶级方法（例如
        <code class="literal">main()</code>），也支持实例函数和类函数（静态函数）。
        你还可以在一个方法内创建另外一个方法（<span class="emphasis"><em>nested（嵌入方法）</em></span> 或者 <span class="emphasis"><em>local
        functions（本地方法）</em></span>）。 </p></li><li class="listitem"><p>同样，Dart 也支持顶级
        <span class="emphasis"><em>变量</em></span>，也支持实例变量和类变量（静态变量）。
        实例变量有时候被称之为 值域或者属性（<em class="firstterm">fields</em> 或者
        <em class="firstterm">properties</em>）。</p></li><li class="listitem"><p>和 Java 不同， Dart 没有 <code class="literal">public</code>、 <code class="literal">protected</code>、 和 <code class="literal">private</code> 关键字。如果名字
        以下划线（_）开头，则是库私有成员。详细信息请参考： <a class="xref" href="ch02.html#libraries" title="库和可见性">the section called “库和可见性”</a>。</p></li><li class="listitem"><p><em class="firstterm">标识符（名字）</em> 可以以字母或者 下划线 开头，后面可以跟随
            任意的字母和数字的组合。</p></li><li class="listitem"><p>有时候需要区分一个东西是
        <span class="emphasis"><em>expression（表达式）</em></span> 还是一个 <span class="emphasis"><em>statement（语句）</em></span>，
        所以我们将区分这两个词语。</p></li><li class="listitem"><p>Dart 工具可以报告两种错误信息：警告和错误。
		警告只是提示你代码可能有潜在的问题，但是并不阻止代码执行。
		错误可能是编译时错误也可能是运行时错误。一个编译时错误阻止代码运行，而运行时
		错误在遇到的时候会抛出一个
        <a class="link" href="ch02.html#exceptions" title="Exceptions（异常）">exception</a> 。</p></li><li class="listitem"><p>Dart 有两种 <em class="firstterm">运行模式</em>：
            生产模式和检测模式（ production
        and checked）。生产模式效率高，但是测试模式可以在开发的时候帮助调试代码。</p></li></ul></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="ch02-keywords"></a>关键字</h3></div></div></div><p><a class="xref" href="ch02.html#keyword_table" title="Table 2.1. Dart 关键字">Table 2.1, “Dart 关键字”</a> 列出了  Dart 语言中的
          关键字。</p><div class="table"><a name="keyword_table"></a><p class="title"><b>Table 2.1. Dart 关键字</b></p><div class="table-contents"><table summary="Dart 关键字" border="1"><colgroup><col><col><col><col><col><col></colgroup><tbody><tr><td>abstract *</td><td>continue</td><td>extends</td><td>implements *</td><td>part *</td><td>throw</td></tr><tr><td>as *</td><td>default</td><td>factory *</td><td>import *</td><td>rethrow</td><td>true</td></tr><tr><td>assert</td><td>do</td><td>false</td><td>in</td><td>return</td><td>try</td></tr><tr><td>break</td><td>dynamic *</td><td>final</td><td>is</td><td>set *</td><td>typedef *</td></tr><tr><td>case</td><td>else</td><td>finally</td><td>library *</td><td>static *</td><td>var</td></tr><tr><td>catch</td><td>enum</td><td>for</td><td>new</td><td>super</td><td>void</td></tr><tr><td>class</td><td>export *</td><td>get *</td><td>null</td><td>switch</td><td>while</td></tr><tr><td>const</td><td>external *</td><td>if</td><td>operator *</td><td>this</td><td>with</td></tr></tbody></table></div></div><p><br class="table-break"></p><p>
          在上表中，带有星号（*）的关键字为
      <span class="emphasis"><em>内置的标识符（built-in identifiers）</em></span>。
      虽然你应该把内置的标识符按照关键字对待，其实真正的限制是无法用内置的标识符作为类或者类型的名字。
	使用内置的标识符可以简化从 JavaScript 移植到 Dart 的过程。
	例如，有些 JavaScript 代码具有一个名字为 <code class="literal">factory</code> 的变量；
	当移植到 Dart 时无需重命名该变量。<em><span class="remark"> 13年十月更新：添加 enum、
      rethrow。 Dart 保留关键字：语言规范的 Section 16.1.1 列举了保留的关键字；  12.31 
      介绍了内置标识符的参考索引。</span></em></p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="ch02-runtime-modes"></a>运行时模式</h3></div></div></div><p>我们建议在检测模式开发，在生产模式部署。</p><p><span class="emphasis"><em>生产模式</em></span>是 Dart 程序的默认运行模式，优化了运行速度。
          生产模式忽略
       <a class="link" href="ch02.html#assert" title="Assert（断言）">assert statements（断言语句）</a> 和静态类型。</p><p><span class="emphasis"><em>检测模式</em></span> 是开发友好模式，
          可以在运行的时候帮助你捕获一些类型错误信息。例如，
          如果你给一个类型为 <code class="literal">num</code> 的变量
      赋值为一个非数字的值，在检测模式会抛出一个异常。</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="variables"></a>变量</h2></div></div></div><p>下面是创建变量并赋值的示例：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>var name = 'Bob';</pre><p>变量是引用。名字为 <code class="literal">name</code> 的变量包含一个指向内容为
      <span class="quote">“<span class="quote">Bob</span>”</span> 的 String 对象。</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="variables-default-value"></a>默认值</h3></div></div></div><p>没有初始化的变量的值为 <code class="literal">null</code>。即使类型为数字的变量其值也是 null，不要忘了 数字在 Dart
      中也是对象。</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>int lineCount;
assert(lineCount == null); 
// 变量的初始值为 null。</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>在生产模式下  <code class="literal">assert()</code> 方法不会被调用。在检测
            模式下，如果 <em class="replaceable"><code>判断条件</code></em> 值为 false ，则 <code class="literal">assert(<em class="replaceable"><code>判断条件</code></em>)</code>
       抛出一个异常。详细信息请参考： <a class="xref" href="ch02.html#assert" title="Assert（断言）">the section called “Assert（断言）”</a>。</p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="variables-optional-types"></a>可选类型</h3></div></div></div><p>在声明变量的时候可以设置一个静态类型：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>String name = 'Bob';</pre><p>添加类型可以明确表达你的意图，可以替代注释。有些工具（例如编译器和编辑器）可以
          使用类型信息帮助你编写代码。</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>本章内容按照 <a class="ulink" href="http://www.dartlang.cc/articles/style-guide/#type-annotations" target="_top"> Dart 风格指南</a>
        推荐的方式用  <code class="literal">var</code> 来定义
        局部变量。</p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="ch02-final-const"></a>Final 和 Const</h3></div></div></div><p>如果你重来不需要修改变量的值，则可以用  <code class="literal">final</code> 或者 <code class="literal">const</code> 来修饰该变量，可以替代 <code class="literal">var</code> 关键字也可以用在类型声明之前。
    	一个 final 类型变量只能设置一次值，一个 const 变量是编译期常量。</p><p>定义为 <code class="literal">final</code> 的本地变量、顶级变量、或者类变量在第一次
      使用的时候初始化：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>final name = 'Bob';   // Or: final String name = 'Bob';
// name = 'Alice';    // 这行代码有错误</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>懒加载 final 变量可以让应用启动速度加快。</p></div><p>用 <code class="literal">const</code> 来定义
          编译期常量。 如果是类常量则用 <code class="literal">static const</code> 来定义。
          实例变量无法用 const 修饰。 在定义变量的时候，可以设置其值为编译期常量，例如：
          字符字面量、const 变量或者常量数字的数学运算结果：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>const bar = 1000000;       // 压力单位 (in dynes/cm2)
const atm = 1.01325 * bar; // 标准大气压</pre></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="built-in-types"></a>内置类型</h2></div></div></div><p>Dart 语言对如下类型有特殊的支持：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>numbers</p></li><li class="listitem"><p>strings</p></li><li class="listitem"><p>booleans</p></li><li class="listitem"><p>lists (也被称之为 <span class="emphasis"><em>arrays</em></span>)</p></li><li class="listitem"><p>maps</p></li><li class="listitem"><p>symbols</p></li></ul></div><p>你可以用字符字面量来初始化上面这些类型。例如  <code class="literal">'this is a
    string'</code> 是一个定义字符串的 字符字面量，而 <code class="literal">true</code> 是一个布尔值字符字面量。</p><p>由于 Dart 总的变量都是引用一个对象，所以可以使用
    <span class="emphasis"><em>构造函数</em></span> 来初始化变量。
    一些内置类型有自己的构造函数。
    例如，可以用 
    <code class="literal">Map()</code> 构造函数来创建一个 map 对象：
    <code class="literal">new Map()</code>。</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="numbers"></a>Numbers</h3></div></div></div><p>Dart 支持两种类型数字：</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><a class="ulink" href="http://api.dartlang.org/dart_core/int.html" target="_top">
          <code class="literal">int</code> </a></span></dt><dd><p>整数值</p></dd><dt><span class="term"><a class="ulink" href="http://api.dartlang.org/dart_core/double.html" target="_top">
          <code class="literal">double</code> </a></span></dt><dd><p>IEEE 754 标准定义的 64-bit (双精度) 浮点数。</p></dd></dl></div><p> <code class="literal">int</code> 和 <code class="literal">double</code> 都是  <a class="ulink" href="http://api.dartlang.org/dart_core/num.html" target="_top"><code class="literal">num</code> 的子类。</a>
      num 类定义了基础的操作符，例如 +、 -、 /、 和 *、，以及位操作符，例如 
      &gt;&gt;。同时还定义了一些常用函数：
      <code class="literal">abs()</code>、<code class="literal"> ceil()</code>、 和
      <code class="literal">floor()</code> 等。
      如果 nub 和子类没有你需要的功能，请查找
      <a class="ulink" href="http://api.dartlang.org/dart_math.html" target="_top">Math</a> 库。
      (在 Dart 代码生成的 JavaScript 中，<a class="ulink" href="http://dartbug.com/1533" target="_top">大整数</a> 和在 
      Dart VM 中执行的  Dart 代码有点区别。)</p><p>Integer 是没有小数点的整数。下面是定义 integer 的一些示例：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>var x = 1;
var hex = 0xDEADBEEF;
var bigInt = 346534658346524376592384765923749587398457294759347029438709349347;</pre><p>如果包含小数点，则为 double。
          下面是定义 double 的示例：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>var y = 1.1;
var exponents = 1.42e5;</pre><p>下面是字符串和数字之间的转换示例：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>// String -&gt; int
var one = int.parse('1');
assert(one == 1);

// String -&gt; double
var onePointOne = double.parse('1.1');
assert(onePointOne == 1.1);

// int -&gt; String
String oneAsString = 1.toString();
assert(oneAsString == '1');

// double -&gt; String
String piAsString = 3.14159.toStringAsFixed(2);
assert(piAsString == '3.14');</pre><p>int 定义了常用的位移操作符 (&lt;&lt;,
      &gt;&gt;), AND (&amp;), 或者 OR (|) 。示例：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>assert((3 &lt;&lt; 1) == 6);  // 0011 &lt;&lt; 1 == 0110
assert((3 &gt;&gt; 1) == 1);  // 0011 &gt;&gt; 1 == 0001
assert((3 | 4)  == 7);  // 0011 | 0100 == 0111</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="strings"></a>Strings</h3></div></div></div><p>Dart 字符串是一个 UTF-16 编码单元序列。 可以用单引号或者双引号定义
          一个 String：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>var s1 = 'Single quotes work well for string literals.';
var s2 = "Double quotes work just as well.";
var s3 = 'It\'s easy to escape the string delimiter.';
var s4 = "It's even easier to just use the other string delimiter.";</pre><p>通过使用 
      <code class="literal">${</code><span class="emphasis"><em><code class="literal">表达式</code></em></span><code class="literal">}</code>
      语法可以把表达式放到字符串中间。
      如果表达式为一个标识符，则可以省略 {}。 Dart 调用
      对象的
      <code class="literal">toString()</code> 函数来获取该对象的字符串值。</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>var s = 'string interpolation';

assert('Dart has $s, which is very handy.' ==
       'Dart has string interpolation, which is very handy.');
assert('That deserves all caps. ${s.toUpperCase()} is very handy!' ==
       'That deserves all caps. STRING INTERPOLATION is very handy!');</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p> <code class="literal">==</code> 操作符测试两个对象是否相等。
            具有同样字符的字符串是相等的。</p></div><p>可以通过相邻字符串字面量或者 
      <code class="literal"><code class="literal">+</code></code> 操作符来连接字符串：</p><pre class="programlisting"><em><span class="remark">lang-dart
adjacent_string_literals.dart
</span></em>var s1 = 'String ' 'concatenation'
         " works even over line breaks.";
assert(s1 == 'String concatenation works even over line breaks.');

var s2 = 'The addition operator '
         + 'works, as well.';
assert(s2 == 'The addition operator works, as well.');</pre><p>使用三个双引号或者单引号可以创建多行字符串：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>var s1 = '''
You can create
multi-line strings like this one.
''';

var s2 = """This is also a
multi-line string.""";</pre><p>在前面添加一个 
      <code class="literal">r</code> 可以创建  <span class="quote">“<span class="quote">raw（未转义）</span>”</span> 字符串：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>var s = r"In a raw string, even \n isn't special.";</pre><p>在字符串中也可以使用 Unicode 转义：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em><em><span class="remark">ch02/quoting.dart
</span></em>print('Unicode escapes work: \u2665'); // Unicode escapes work: [heart]</pre><p>关于使用 String 的更多信息，请参考  <a class="xref" href="ch03.html#ch03-strings-and-regular-expressions" title="字符串（String）和正则表达式">the section called “字符串（String）和正则表达式”</a>。</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="booleans"></a>Booleans</h3></div></div></div><p>Dart 用 <code class="literal">bool</code> 类型代表布尔值。类型 bool 只有两个对象：
      布尔字面量 <code class="literal">true</code> 和 <code class="literal">false</code>。</p><p>当 Dart 需要布尔值的时候， 只有  <code class="literal">true</code> 被认为是 true。
      其他所有的值都认为是 false。和 JavaScript 不同，
      像  <code class="literal">1</code>、 <code class="literal">"aString"</code>、和 <code class="literal">someObject</code> 在 Dart 中都是 false。</p><p>例如 下面的代码在 JavaScript 和 Dart 中都是合法的：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>var name = 'Bob';
if (name) {
  print('You have a name!'); // 在 JavaScript 中会执行该语句 ，而 Dart 中不会执行。
}</pre><p>由于 <code class="literal">name</code> 不是
          一个 null 对象，所以在 JavaScript 运行上面代码则会打印出 <span class="quote">“<span class="quote">You have a
      name!</span>”</span>。而 在 Dart 的 <span class="emphasis"><em>生产模式
       </em></span>下，不会输出任何内容，原因在于，
        <code class="literal">name</code> 被转换成了 <code class="literal">false</code> (因为 <code class="literal">name
      != true</code>)。在 Dart 的 <span class="emphasis"><em>检测模式
       </em></span>下，由于
       <code class="literal">name</code> 变量不是一个布尔值 会导致抛出异常。
       </p><p>下面是另外一个 
      JavaScript 和 Dart 代码行为不一致的示例：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>if (1) {
  print('JavaScript prints this line because it thinks 1 is true.');
} else {
  print('Dart in production mode prints this line.');
  // 在 Dart 的检测模式下 if (1) 会抛出异常。
}</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>上面的两个示例只有在生产模式下能够运行。在检测模式下，如果把非布尔值当做布尔值用
            会抛出异常。</p></div><p>Dart 只把 true 当做 true，而不是其他对象，可以避免很多不可预料的问题。你不应该这样用：<code class="literal">if (<em class="replaceable"><code>nonbooleanValue</code></em>)</code>，而
      应该用你期望的值。例如：
      </p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>// 检测空字符串
var fullName = '';
assert(fullName.isEmpty);

// 检测是否为 0
var hitPoints = 0;
assert(hitPoints &lt;= 0);

// 检测 null.
var unicorn;
assert(unicorn == null);

// 检测  NaN.
var iMeantToDoThis = 0/0;
assert(iMeantToDoThis.isNaN);</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="lists"></a>Lists</h3></div></div></div><p> <span class="emphasis"><em>array</em></span>（数组）也许是大多数编程语言中最常用的集合。
          在 Dart 中，  数组为 <a class="ulink" href="http://api.dartlang.org/dart_core/List.html" target="_top">List</a> 对象，
      所以一般我们都称之为  <span class="emphasis"><em>lists（列表）</em></span>。</p><p>Dart 列表字面量定义和 JavaScript 中的 数组定义类似。下面
          是一个定义 Dart 列表的示例：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>var list = [1,2,3];</pre><p>列表的索引从 0 开始， 0 是第一个元素而
      <code class="literal">list.length - 1</code> 是最后一个元素。
      获取列表的长度和元素与 JavaScript 中的操作一样：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>var list = [1,2,3];
assert(list.length == 3);
assert(list[1] == 2);</pre><p>List 类定义了很多操作列表的函数。详细信息请参考  <a class="xref" href="ch02.html#generics" title="Generics（泛型）">the section called “Generics（泛型）”</a> 和 <a class="xref" href="ch03.html#ch03-collections" title="集合">the section called “集合”</a>。</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="maps"></a>Maps</h3></div></div></div><p>一般来说，一个 map 是一个把键（key）和值（value）关联起来的对象。
          键和值都可以为任意类型的对象。一个
      <span class="emphasis"><em>键</em></span> 只能出现一次，但是一个
      <span class="emphasis"><em>值</em></span> 可以设置到多个键上。 Dart 通过
      map 字面量和  <a class="ulink" href="http://api.dartlang.org/dart_core/Map.html" target="_top">Map</a>
      类型支持 Map。</p><p>下面是用 map 字面量创建 Map 对象的一些示例：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>var gifts = {
// Keys       Values
  'first'  : 'partridge',
  'second' : 'turtledoves',
  'fifth'  : 'golden rings'
};

var nobleGases = {
// Keys  Values
   2  : 'helium',
   10 : 'neon',
   18 : 'argon',
};
</pre><p>也可以用 Map 构造函数创建这些对象：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em><em><span class="remark">ch02/map_constructor.dart
</span></em>var gifts = new Map();
gifts['first'] = 'partridge';
gifts['second'] = 'turtledoves';
gifts['fifth'] = 'golden rings';

var nobleGases = new Map();
nobleGases[2] = 'helium';
nobleGases[10] = 'neon';
nobleGases[18] = 'argon';</pre><p>往 map 对象中添加 键-值 对和 JavaScript 中的操作一样:</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>var gifts = { 'first': 'partridge' };
gifts['fourth'] = 'calling birds';    // Add a key-value pair</pre><p>从 map 中获取值也和 JavaScript 一样：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>var gifts = { 'first': 'partridge' };
assert(gifts['first'] == 'partridge');</pre><p>如果一个 键 不在 map 中，则返回的值为 null：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>var gifts = { 'first': 'partridge' };
assert(gifts['fifth'] == null);</pre><p>用 <code class="literal">.length</code> 来获取 map 中
          键值对的个数：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>var gifts = { 'first': 'partridge' };
gifts['fourth'] = 'calling birds';
assert(gifts.length == 2);</pre><p>关于 map 的详细信息请参考：<a class="xref" href="ch02.html#generics" title="Generics（泛型）">the section called “Generics（泛型）”</a>
      和 <a class="xref" href="ch03.html#ch03-maps-aka-dictionaries-or-hashes" title="Maps">the section called “Maps”</a>。</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="ch02-symbols"></a>Symbols（符号）</h3></div></div></div><p>一个 <a class="ulink" href="http://api.dartlang.org/dart_core/Symbol.html" target="_top">Symbol</a>
      对象代表 Dart 代码中的一个操作符或者一个标识符。你可能无需使用 Symbol，但是对于需要访问 标识符 名字的 API 来说，
      Symbol 是非常有用的，对于混淆过的代码， Symbol 也返回混淆之前的标识符名字。</p><p>要获取一个标识符的 Symbol，可以 用 symbol 字面量定义：
      一个 <code class="literal">#</code>后面跟着标识符的名字 </p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>#radix  // The symbol literal for an identifier named 'radix'.
#bar    // The symbol literal for an identifier named 'bar'.</pre><p>关于 symbol 的详细信息，请参考  <a class="xref" href="ch03.html#ch03-mirrors" title="dart:mirrors - Reflection（反射）">the section called “dart:mirrors - Reflection（反射）”</a>。</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="functions"></a>Functions（方法）</h2></div></div></div><p>下面是实现一个方法的示例：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>void printNumber(num number) {
  print('The number is $number.');
}</pre><p>虽然风格指南中建议设置参数和返回值的类型，但是你也可以不这么做：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>printNumber(number) {          // 不设置类型也可以
  print('The number is $number.');
}</pre><p>对于只有一个表达式的方法，你可以用缩写形式：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>printNumber(number) =&gt; print('The number is $number.');</pre><p> <code class="literal">=&gt;
    <em class="replaceable"><code>expr</code></em>;</code> 语法是
    <code class="literal">{ return
    <em class="replaceable"><code>expr</code></em>;}</code> 的缩写形式。
    在上面的
    <code class="literal">printNumber()</code> 方法中，表达式为
    顶级方法 <code class="literal">print()</code>。</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
      在 <span class="keep-together">arrow (=&gt;)</span> 和 分号 (;) 之间只能是
      <span class="emphasis"><em>expression（表达式）</em></span>，不能用 <span class="emphasis"><em>statement（语句）</em></span> 。
      例如，不能用
       <a class="link" href="ch02.html#if-else" title="If 和 Else"><span class="keep-together">if statement</span></a>，但是可以用
      <a class="link" href="ch02.html#op-other" title="其他操作符">条件 (<code class="literal">?:</code>)
      表达式</a>。</p></div><p> =&gt; 也可以使用参数类型（代码风格指南不建议使用类型）：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>printNumber(num number) =&gt; print('The number is $number.'); // Types are OK.</pre><p>调用方法的示例：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>printNumber(123);</pre><p>方法参数有两种类型：必需的和可选的。
        必需的参数出现在可选参数前面。</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="functions-optional-parameters"></a>可选参数</h3></div></div></div><p>可选参数可以是命名参数或者位置参数。但是不能同时使用这两种类型。</p><p>可选参数可以有默认值。默认值必需为编译期常量，例如 字面量定义。
          如果没有提供默认值，则默认值为 
       <code class="literal">null</code>。</p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="functions-optional-named-parameters"></a>可选命名参数</h4></div></div></div><p>使用
        <code class="literal"><em class="replaceable"><code>paramName</code></em>:
        <em class="replaceable"><code>value</code></em></code> 可以设置方法的命名参数。例如：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>enableFlags(bold: true, hidden: false);</pre><p>用  <code class="literal">{<em class="replaceable"><code>param1</code></em>,
        <em class="replaceable"><code>param2</code></em>, …}</code> 来定义方法的 命名参数：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>/// Sets the [bold] and [hidden] flags to the values you specify.
enableFlags({bool bold, bool hidden}) {
  // ...
}</pre><p>使用冒号 (<code class="literal">:</code>) 来设置默认值：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>/**
 * Sets the [bold] and [hidden] flags to the values you specify,
 * defaulting to false.
 */
enableFlags({bool bold: false, bool hidden: false}) {
  // ...
}

enableFlags(bold: true); // bold 的值为 true; hidden 没指定则为默认值 false.</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="functions-optional-positional-parameters"></a>可选位置参数</h4></div></div></div><p>位于 <code class="literal">[]</code> 中间的参数为可选位置  <span class="keep-together">参数</span>：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>String say(String from, String msg, [String device]) {
  var result = '$from says $msg';
  if (device != null) {
    result = '$result with a $device';
  }
  return result;
}</pre><p>下面是没有设置可选位置参数的调用示例：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>assert(say('Bob', 'Howdy') == 'Bob says Howdy');</pre><p>下面是设置了可选位置参数的示例：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>assert(say('Bob', 'Howdy', 'smoke signal') ==
  'Bob says Howdy with a smoke signal');</pre><p>用 <code class="literal">=</code> 设置默认值：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>String say(String from, String msg,
  [String device='carrier pigeon', String mood]) {
  var result = '$from says $msg';
  if (device != null) {
    result = '$result with a $device';
  }
  if (mood != null) {
    result = '$result (in a $mood mood)';
  }
  return result;
}

assert(say('Bob', 'Howdy') == 'Bob says Howdy with a carrier pigeon');</pre></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="ch02-main"></a> main() 方法</h3></div></div></div><p>每个应用都有一个顶级的 <code class="literal">main()</code> 方法，
          该方法为程序的执行入口。
      <code class="literal">main()</code> 方法的返回值为 <code class="literal">void</code> 并有个可选
       <code class="literal">List&lt;String&gt;</code> 参数来接收程序参数。</p><p>下面是一个 web 应用中的 <code class="literal">main()</code> 方法示例：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>main() {
  querySelector("#sample_text_id")
    ..text = "Click me!"
    ..onClick.listen(reverseText);
}</pre><p>下面是带有两个参数的命令行程序 <code class="literal">main()</code> 方法示例：</p><pre class="programlisting"><em><span class="remark">lang-dart
ch02/args.dart
</span></em>// 通过命令运行该程序： dart args.dart 1 test
void main(List&lt;String&gt; arguments) {
  print(arguments);

  assert(arguments.length == 2); 
  assert(int.parse(arguments[0]) == 1);
  assert(arguments[1] == 'test'); 
}</pre><p>可以用 <a class="ulink" href="http://api.dartlang.org/args.html" target="_top">args 库</a> 
      来定义和解析命令行参数。</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="ch02-functions-first-class"></a>（方法作为一等对象）Functions as First-Class Objects</h3></div></div></div><p>可以把方法作为方法的参数使用：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>printElement(element) {
  print(element);
}
  
var list = [1,2,3];
list.forEach(printElement); // 把 printElement 方法当做参数来用</pre><p>还可以用一个变量来保存方法引用：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>var loudify = (msg) =&gt; '!!! ${msg.toUpperCase()} !!!';
assert(loudify('hello') == '!!! HELLO !!!');</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="ch02-lexical-scope"></a>（语法作用域）Lexical Scope</h3></div></div></div><p>Dart 是一种语法作用域语言，也就是说 变量的作用域
          是根据代码布局静态判断的。
          可以根据“变量位于花括号内外”来判断一个变量是否在作用域中。
      </p><p>下面是一个嵌套函数变量作用域示例：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>var topLevel = true;
main() {
    var insideMain = true;
    
    myFunction() {
      var insideFunction = true;
      
      nestedFunction() {
        var insideNestedFunction = true;
        assert(topLevel);
        assert(insideMain);
        assert(insideFunction);
        assert(insideNestedFunction);
      }
    }
}</pre><p>注意 <code class="literal">nestedFunction()</code> 可以
          使用外面所有花括号内的变量。</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="ch02-functions-lexical-closures"></a>（语法闭包）Lexical Closures</h3></div></div></div><p>一个 <span class="emphasis"><em>closure（闭包）</em></span> 是一个可以
          访问位于其语法作用域内变量的方法对象，即时该方法用在其定义的作用域之外，也可以访问这些变量。
      </p><p>方法可以覆盖定义在附近作用域的变量
          （Functions can close over variables defined in surrounding scopes）。
          在下面的示例中，
       <code class="literal">adder()</code> 捕获变量
        <code class="literal">addBy</code>。
        无论在哪里使用返回的 adder 函数，该函数都记得
       <code class="literal">addBy</code> 参数的值。</p><pre class="programlisting"><em><span class="remark">lang-dart</span></em><em><span class="remark">
ch02/function_closure.dart
</span></em>/// Returns a function that adds [addBy] to a number.
Function makeAdder(num addBy) {
  adder(num i) {
    return addBy + i;
  }
  return adder;
}

main() {
  var add2 = makeAdder(2); // Create a function that adds 2.
  var add4 = makeAdder(4); // Create a function that adds 4.

  assert(add2(3) == 5);
  assert(add4(3) == 7);
}</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="ch02-function-equality"></a>判断函数相等</h3></div></div></div><p>下面是测试顶级方法、静态函数、和实例函数相等的示例：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em><em><span class="remark">ch02/function_equality_2.dart
</span></em>foo() {}               // A top-level function

class SomeClass {
  static void bar() {} // A static method
  void baz() {}        // An instance method
}

main() {
  var x;
  
  // Comparing top-level functions.
  x = foo;
  assert(x == foo);
  
  // Comparing static methods.
  x = SomeClass.bar;
  assert(x == SomeClass.bar);
  
  // Comparing instance methods.
  var v = new SomeClass();
  var w = new SomeClass();
  var y = v;
  x = v.baz;
  
  assert(x == y.baz);
  assert(v.baz != w.baz);
}</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="ch02-functions-return-values"></a>返回值</h3></div></div></div><p>每个方法都有一个返回值。如果没有指定返回值，则默认会在函数最后附加一个
      <code class="literal">return null;</code> 的语句。</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="operators"></a>操作符</h2></div></div></div><p>Dart 定义了  <a class="xref" href="ch02.html#operator_table" title="Table 2.2. 操作符和优先级">Table 2.2, “操作符和优先级”</a> 表中的操作符。 很多操作符都可以重写，在
     <a class="xref" href="ch02.html#classes-operators" title="重写操作符">the section called “重写操作符”</a> 介绍了如何重写操作符。</p><div class="table"><a name="operator_table"></a><p class="title"><b>Table 2.2. 操作符和优先级</b></p><div class="table-contents"><table summary="操作符和优先级" border="1"><colgroup><col><col></colgroup><thead><tr><th>描述</th><th>操作符</th></tr></thead><tbody><tr><td>一元后缀操作符</td><td><em class="replaceable"><code>expr</code></em>++
               <em class="replaceable"><code>expr</code></em>--    ()
               []    .</td></tr><tr><td>一元前缀操作符</td><td>-<em class="replaceable"><code>expr</code></em>
               !<em class="replaceable"><code>expr</code></em>   
            ~<em class="replaceable"><code>expr</code></em>   
            ++<em class="replaceable"><code>expr</code></em>   
            --<em class="replaceable"><code>expr</code></em>   </td></tr><tr><td>乘除</td><td>*    /    %
               ~/</td></tr><tr><td>加减</td><td>+    -</td></tr><tr><td>位移</td><td>&lt;&lt;    &gt;&gt;</td></tr><tr><td>位与 AND</td><td>&amp;</td></tr><tr><td>位异或 XOR</td><td>^</td></tr><tr><td>位或 OR</td><td>|</td></tr><tr><td>关系和类型测试</td><td>&gt;=    &gt;   
            &lt;=    &lt;    as    is
               is!</td></tr><tr><td>相等</td><td>==    !=
              </td></tr><tr><td>逻辑与 AND</td><td>&amp;&amp;</td></tr><tr><td>逻辑或 OR</td><td>||</td></tr><tr><td>条件表达式</td><td><em class="replaceable"><code>expr1</code></em> ?
            <em class="replaceable"><code>expr2</code></em> :
            <em class="replaceable"><code>expr3</code></em></td></tr><tr><td>级联操作符</td><td>..</td></tr><tr><td>赋值</td><td>=    *=    /=
               ~/=    %=    +=    -=
               &lt;&lt;=    &gt;&gt;=    &amp;=
               ^=    |=   </td></tr></tbody></table></div></div><br class="table-break"><p>当使用操作符的时候，就会创建一个
    <em class="firstterm">表达式</em>。
    下面是一些操作符表达式的示例：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>a++
a + b
a = b
a == b
a? b: c
a is T</pre><p>在 <a class="xref" href="ch02.html#operator_table" title="Table 2.2. 操作符和优先级">Table 2.2, “操作符和优先级”</a> 中，每一行操作符都比其下面的操作符优先级要高。
    例如，除法操作符 <code class="literal">%</code> 比  <code class="literal">==</code> 操作符优先级高，而  <code class="literal">==</code> 又比
     <code class="literal">&amp;&amp;</code> 优先级高。
     所以下面的两行代码是一样的：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>if ((n % i == 0) &amp;&amp; (d % i == 0)) // 使用括号提高代码可读性
if (n % i == 0 &amp;&amp; d % i == 0)     // 虽然难读，但是效果一样</pre><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>
          对于连接两个操作数的操作符来说，左边的操作数决定使用那个版本的操作符。例如
          ，如果你有一个 Vector 对象和一个 Point 对象， <code class="literal">aVector + aPoint</code> 则用 Vector 
  版本的 + 操作符。</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="op-arithmetic"></a>算术操作符</h3></div></div></div><p>Dart  支持常规的算术操作符，如  <a class="xref" href="ch02.html#arithmetic_operator_table" title="Table 2.3. 算术操作符">Table 2.3, “算术操作符”</a> 表格所示：</p><div class="table"><a name="arithmetic_operator_table"></a><p class="title"><b>Table 2.3. 算术操作符</b></p><div class="table-contents"><table summary="算术操作符" border="1"><colgroup><col><col></colgroup><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>+</td><td>加号</td></tr><tr><td>–</td><td>减号</td></tr><tr><td>-<em class="replaceable"><code>expr</code></em></td><td>负号</td></tr><tr><td>*</td><td>乘号</td></tr><tr><td>/</td><td>除号</td></tr><tr><td>~/</td><td>整除号</td></tr><tr><td>%</td><td>取余</td></tr></tbody></table></div></div><br class="table-break"><p>示例：</p><pre class="programlisting"><em><span class="remark">lang-dart</span></em><em><span class="remark">
ch02/arithmetic_operators.dart
</span></em>assert(2 + 3 == 5);
assert(2 - 3 == -1);
assert(2 * 3 == 6);
assert(5 / 2 == 2.5);   // Result is a double
assert(5 ~/ 2 == 2);    // Result is an integer
assert(5 % 2 == 1);     // Remainder

print('5/2 = ${5~/2} remainder ${5%2}'); // 5/2 = 2 remainder 1</pre><p>Dart 也支持前缀和后缀 加和减 操作符。</p><div class="table"><a name="pfix_operator_table"></a><p class="title"><b>Table 2.4. 加减操作符</b></p><div class="table-contents"><table summary="加减操作符" border="1"><colgroup><col><col></colgroup><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>++<em class="replaceable"><code>var</code></em></td><td><em class="replaceable"><code>var</code></em> =
              <em class="replaceable"><code>var</code></em> + 1 (expression value is
              <em class="replaceable"><code>var</code></em> + 1)</td></tr><tr><td><em class="replaceable"><code>var</code></em>++</td><td><em class="replaceable"><code>var</code></em> =
              <em class="replaceable"><code>var</code></em> + 1 (expression value is
              <em class="replaceable"><code>var</code></em>)</td></tr><tr><td>--<em class="replaceable"><code>var</code></em></td><td><em class="replaceable"><code>var</code></em> =
              <em class="replaceable"><code>var</code></em> – 1 (expression value is
              <em class="replaceable"><code>var</code></em> – 1)</td></tr><tr><td><em class="replaceable"><code>var</code></em>--</td><td><em class="replaceable"><code>var</code></em> =
              <em class="replaceable"><code>var</code></em> – 1 (expression value is
              <em class="replaceable"><code>var</code></em>)</td></tr></tbody></table></div></div><br class="table-break"><p>示例：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>var a, b;

a = 0;  
b = ++a;         // Increment a before b gets its value.
assert(a == b);  // 1 == 1  

a = 0;
b = a++;         // Increment a AFTER b gets its value.
assert(a != b);  // 1 != 0

a = 0;
b = --a;         // Decrement a before b gets its value.
assert(a == b);  // -1 == -1

a = 0;
b = a--;         // Decrement a AFTER b gets its value.
assert(a != b) ; // -1 != 0</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="op-equality"></a>关系和相等操作符</h3></div></div></div><div class="table"><a name="equality_operator_table"></a><p class="title"><b>Table 2.5. 关系和相等操作符</b></p><div class="table-contents"><table summary="关系和相等操作符" border="1"><colgroup><col><col></colgroup><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>==</td><td>相等</td></tr><tr><td>!=</td><td>不等</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;=</td><td>大于等于</td></tr><tr><td>&lt;=</td><td>小于等于</td></tr></tbody></table></div></div><br class="table-break"><p>用 <code class="literal">==</code> 来测试两个对象 <em class="replaceable"><code>x</code></em> 和
      <em class="replaceable"><code>y</code></em> 是否代表同一个东西。
      (在极少数情况下，你需要知道两个对象是否是同一个对象，则使用
      <code class="literal"><a class="ulink" href="http://api.dartlang.org/dart_core.html#identical" target="_top">identical()</a></code>
      函数。) 下面是 <code class="literal">==</code>
      操作符工作原理：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>如果 <em class="replaceable"><code>x</code></em> 或者
          <em class="replaceable"><code>y</code></em> 是 null，只有当另外一个也是 null 的时候才返回 true，
          否则只有一个为 null 则返回 false。</p></li><li class="listitem"><p>然后执行 <code class="literal"><em class="replaceable"><code>x</code></em>.==(<em class="replaceable"><code>y</code></em>)</code> 函数。
          (没错， <code class="literal">==</code> 操作符就是第一个对象的函数。
          你也可以重写大部分操作符，包括 
          <code class="literal">==</code>，在  <a class="xref" href="ch02.html#classes-operators" title="重写操作符">the section called “重写操作符”</a> 介绍如何重写操作符。)</p></li></ol></div><p>下面是使用关系和等于操作符的示例：</p><pre class="programlisting"><em><span class="remark">lang-dart</span></em><em><span class="remark">
ch02/op_equality.dart
</span></em>assert(2 == 2);
assert(2 != 3);
assert(3 &gt; 2);
assert(2 &lt; 3);
assert(3 &gt;= 3);
assert(2 &lt;= 3);</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="ch02-op-type-test"></a>类型测试操作符</h3></div></div></div><p> <code class="literal">as</code>、 <code class="literal">is</code>、和 <code class="literal">is!</code>
      操作符是运行时判断类型的操作符。
      </p><div class="table"><a name="type_test_operator_table"></a><p class="title"><b>Table 2.6. 类型测试操作符</b></p><div class="table-contents"><table summary="类型测试操作符" border="1"><colgroup><col><col></colgroup><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>as</td><td>Typecast（类型转换）</td></tr><tr><td>is</td><td>如果 对象是该类型 则返回 true</td></tr><tr><td>is!</td><td>如果 对象是该类型 则返回  false</td></tr></tbody></table></div></div><br class="table-break"><p>
          只有当 <code class="literal">obj</code> 实现了 <code class="literal">T</code> 接口（类）
          的时候，  <code class="literal">obj is T</code> 的结果才是 true 。 例如 <code class="literal">obj is Object</code> 总是返回 true。</p><p>用 <code class="literal">as</code> 操作符把一个对象转换为
          另外一个类型。
          通常 用来替换 <code class="literal">is</code> 判断后跟一个使用该 对象的表达式。
          例如，下面的示例：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>if (person is Person) {               // Type check
  person.firstName = 'Bob';
}</pre><p>使用 <code class="literal">as</code> 操作符可以简化代码：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>(person as Person).firstName = 'Bob';</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>注意：上面的代码并不等同。如果 <code class="literal">person</code> 是 null
        或者 不是一个  Person，第一个示例 (使用 <code class="literal">is</code> 的) 不执行后面的代码；
        而第二个示例  (使用 <code class="literal">as</code> 的) 则会抛出一个 <span class="keep-together">异常</span>。</p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="op-assign"></a>赋值操作符</h3></div></div></div><p>前面已经见到过了，用 <code class="literal">=</code> 来赋值。也可以用复合赋值操作符
      来赋值，例如 <code class="literal">+=</code>。</p><div class="table"><a name="assignment_operator_table"></a><p class="title"><b>Table 2.7. 赋值操作符</b></p><div class="table-contents"><table summary="赋值操作符" border="1"><colgroup><col><col><col><col><col><col></colgroup><tbody><tr><td>=</td><td>–=</td><td>/=</td><td>%=</td><td>&gt;&gt;=</td><td>^=</td></tr><tr><td>+=</td><td>*=</td><td>~/=</td><td>&lt;&lt;=</td><td>&amp;=</td><td>|=</td></tr></tbody></table></div></div><br class="table-break"><p>下面是复合赋值操作符的工作原理</p><div class="informaltable"><a name="assignment_operator_concepts_table"></a><table border="1"><colgroup><col><col><col></colgroup><thead><tr><th> </th><th>复合赋值操作符</th><th>等同的表达式</th></tr></thead><tbody><tr><td><span class="bold"><strong>对于一个操作符
              <em class="replaceable"><code>op</code></em>:</strong></span></td><td><code class="literal">a <em class="replaceable"><code>op</code></em>=
              b</code></td><td><code class="literal">a = a
              <em class="replaceable"><code>op</code></em> b</code></td></tr><tr><td><span class="bold"><strong>示例 </strong></span></td><td><code class="literal">a += b</code></td><td><code class="literal">a = a + b</code></td></tr></tbody></table></div><p>下面示例使用了 赋值和复合赋值操作符：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>var a = 2;           // Assign using =
a *= 3;              // Assign and multiply: a = a * 3
assert(a == 6);</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="op-logical"></a>逻辑操作符（逻辑运算符）</h3></div></div></div><p>逻辑操作符可以组合和取反义操作。</p><div class="table"><a name="logical_operator_table"></a><p class="title"><b>Table 2.8. 逻辑操作符</b></p><div class="table-contents"><table summary="逻辑操作符" border="1"><colgroup><col><col></colgroup><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>!<em class="replaceable"><code>expr</code></em></td><td>取表达式的反义 （如果表达式为 true，则结果为 false，反之亦然。）</td></tr><tr><td>||</td><td>逻辑或 OR</td></tr><tr><td>&amp;&amp;</td><td>逻辑与 AND</td></tr></tbody></table></div></div><br class="table-break"><p>下面是使用逻辑操作符的示例：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>if (!done &amp;&amp; (col == 0 || col == 3)) {
  // ...Do something...
}</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="op-bit"></a>位和移位操作符</h3></div></div></div><p>
          在 Dart 中可以操作每个数字的字节。
          通常在整数上使用 位和移位操作符。如下表所示 <a class="xref" href="ch02.html#bit_operator_table" title="Table 2.9. 位和移位操作符">Table 2.9, “位和移位操作符”</a> 的操作符：</p><div class="table"><a name="bit_operator_table"></a><p class="title"><b>Table 2.9. 位和移位操作符</b></p><div class="table-contents"><table summary="位和移位操作符" border="1"><colgroup><col><col></colgroup><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>&amp;</td><td>AND</td></tr><tr><td>|</td><td>OR</td></tr><tr><td>^</td><td>XOR</td></tr><tr><td>~<em class="replaceable"><code>expr</code></em></td><td>一元位补码操作符 (0s 变为 1s； 1s 变为
              0s)</td></tr><tr><td>&lt;&lt;</td><td>左移</td></tr><tr><td>&gt;&gt;</td><td>右移</td></tr></tbody></table></div></div><br class="table-break"><p>下面是使用位和移位操作符的示例：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>final value = 0x22;
final bitmask = 0x0f;

assert((value &amp; bitmask)  == 0x02);  // AND
assert((value &amp; ~bitmask) == 0x20);  // AND NOT
assert((value | bitmask)  == 0x2f);  // OR
assert((value ^ bitmask)  == 0x2d);  // XOR
assert((value &lt;&lt; 4)       == 0x220); // Shift left
assert((value &gt;&gt; 4)       == 0x02);  // Shift right</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="op-other"></a>其他操作符</h3></div></div></div><p>其他一些没介绍的操作符，但是大部分你应该在其他地方都看到过了。</p><div class="table"><a name="other_operator_table"></a><p class="title"><b>Table 2.10. 其他操作符</b></p><div class="table-contents"><table summary="其他操作符" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>操作符</th><th>名字</th><th>描述</th></tr></thead><tbody><tr><td>()</td><td>方法调用</td><td>代表调用一个方法</td></tr><tr><td>[]</td><td>List 访问</td><td>获取 list 某个位置的内容</td></tr><tr><td><em class="replaceable"><code>expr1</code></em> ? <em class="replaceable"><code>expr2</code></em> : <em class="replaceable"><code>expr3</code></em></td><td>条件表达式</td><td>如果 <em class="replaceable"><code>expr1</code></em> 是 true，执行 
              <em class="replaceable"><code>expr2</code></em>；否则，执行
              <em class="replaceable"><code>expr3</code></em></td></tr><tr><td>.</td><td>成员访问</td><td>访问一个成员，例如 <code class="literal">foo.bar</code> 选择属性 ，访问
              <code class="literal">foo</code>
              对象的 <code class="literal">bar</code> 属性 </td></tr><tr><td>..</td><td>级联操作符</td><td>可以在同一个对象上执行多个炒作 ，参考  <a class="xref" href="ch02.html#classes" title="Classes">the section called “Classes”</a></td></tr></tbody></table></div></div><br class="table-break"></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="control-flow-statements"></a>控制流程语句</h2></div></div></div><p>使用如下控制语句可以控制 Dart 代码的执行流程：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">if</code> 和 <code class="literal">else</code></p></li><li class="listitem"><p><code class="literal">for</code> 循环</p></li><li class="listitem"><p><code class="literal">while</code> 和 <code class="literal">do</code>-<code class="literal">while</code>
        循环</p></li><li class="listitem"><p><code class="literal">break</code> 和 <code class="literal">continue</code></p></li><li class="listitem"><p><code class="literal">switch</code> 和 <code class="literal">case</code></p></li><li class="listitem"><p><code class="literal">assert</code></p></li></ul></div><p>使用  <code class="literal">try-catch</code> 和 <code class="literal">throw</code> 也可以影响执行流程，在 <a class="xref" href="ch02.html#exceptions" title="Exceptions（异常）">the section called “Exceptions（异常）”</a> 中有详细介绍。</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="if-else"></a>If 和 Else</h3></div></div></div><p>Dart 支持 <code class="literal">if</code> 语句和可选的
      <code class="literal">else</code> 语句。
      在  <a class="xref" href="ch02.html#op-other" title="其他操作符">the section called “其他操作符”</a> 还介绍了条件表达式 (?:)。</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>if (isRaining()) {
  you.bringRainCoat();
} else if (isSnowing()) {
  you.wearJacket();
} else {
  car.putTopDown();
}</pre><p>注意： Dart 和 JavaScript 不同， 在 Dart 中只有
      <code class="literal">true</code> 才被当做 true，所有其他对象都是 <code class="literal">false</code>。详细信息参考 <a class="xref" href="ch02.html#booleans" title="Booleans">the section called “Booleans”</a> 。</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="for-loops"></a>For 循环</h3></div></div></div><p>如下是标准的 <code class="literal">for</code> 循环示例：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em><em><span class="remark">ch02/flow_for_loops.dart
</span></em>var message = new StringBuffer("Dart is fun");
for (var i = 0; i &lt; 5; i++) {
  message.write('!');
}</pre><p> Dart <code class="literal">for</code>循环中的闭包捕获
          循环的索引，避免 JavaScript 中出现的弊端。例如：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em><em><span class="remark">ch02/flow_for_loops.dart
</span></em>var callbacks = [];
for (var i = 0; i &lt; 2; i++) {
  callbacks.add(() =&gt; print(i));
}
callbacks.forEach((c) =&gt; c());</pre><p>打印的结果为  <code class="literal">0</code> 然后是 
      <code class="literal">1</code>，和预期的结果一样。
      而在 JavaScript 中，结果会是  <code class="literal">2</code> 和
      <code class="literal">2</code> 。</p><p>如果循环的对象是一个 Iterable ，则可以用 <code class="literal"><a class="ulink" href="http://api.dartlang.org/dart_core/Iterable.html#forEach" target="_top">forEach()</a></code>
      函数。如果无需关心当前的循环索引，则使用 <code class="literal">forEach()</code>
      是更好的选择：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em><em><span class="remark">ch02/flow_for_loops.dart
</span></em>candidates.forEach((candidate) =&gt; candidate.interview());</pre><p>像 List 和 Set 这种 Iterable 对象还支持 <code class="literal">for-in</code> 循环，在
      <span lang="" class="phrase">in <a class="xref" href="ch03.html#ch03-iteration" title="Iteration（遍历）">the section called “Iteration（遍历）”</a> 有介绍：</span></p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em><em><span class="remark">ch02/flow_for_loops.dart
</span></em>var collection = [0, 1, 2];
for (var x in collection) {
  print(x);
}</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="while"></a>While 和 Do-While</h3></div></div></div><p>一个 <code class="literal">while</code> 循环会在循环开始之前先
          计算条件的值：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>while(!isDone()) {
  doSomething();
}</pre><p>而 一个 <code class="literal">do</code>-<code class="literal">while</code>  循环会先循环后计算
      条件的值：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>do {
  printLine();
} while (!atEndOfPage());</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="break"></a>Break 和 Continue</h3></div></div></div><p>使用 <code class="literal">break</code> 来终止
          循环：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>while (true) {
  if (shutDownRequested()) break;
  processIncomingRequests();
}</pre><p>使用 <code class="literal">continue</code> 
	来跳到下一个循环：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>for (int i = 0; i &lt; candidates.length; i++) {
  var candidate = candidates[i];
  if (candidate.yearsExperience &lt; 5) {
    continue;
  }
  candidate.interview();
}</pre><p>如果使用  list 或者 set 则实现方式可以有所不同：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>candidates.where((c) =&gt; c.yearsExperience &gt;= 5)
          .forEach((c) =&gt; c.interview());</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="switch"></a>Switch 和 Case</h3></div></div></div><p>Dart 中的 Switch 语句用 <code class="literal">==</code> 来比较 integer、 string、或者编译期常量
           。被比较的对象必须为同一个类的实例（子类型不可以），并且类必须没有重写 <code class="literal">==</code> 操作符。</p><p>规则需要每个非空 <code class="literal">case</code> 块以
       <code class="literal">break</code> 语句结尾。
      其他非空
      <code class="literal">case</code> 块可以是一个
      <code class="literal">continue</code>、 <code class="literal">throw</code>、或者 <code class="literal">return</code> 语句。</p><p>使用一个 <code class="literal">default</code> 语句来执行
          不匹配任何 <code class="literal">case</code> 语句的情况：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>var command = 'OPEN';
switch (command) {
  case 'CLOSED':
    executeClosed();
    break;
  case 'PENDING':
    executePending();
    break;
  case 'APPROVED':
    executeApproved();
    break;
  case 'DENIED':
    executeDenied();
    break;
  case 'OPEN':
    executeOpen();
    break;
  default:
    executeUnknown();
}</pre><p>下面的示例代码在 <code class="literal">case</code> 块中忘记添加
       <code class="literal">break</code> 语句了， 这样会产生一个错误：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>var command = 'OPEN';
switch (command) {
  case 'OPEN':
    executeOpen();
    // ERROR: 丢掉 break 语句会抛出一个异常！！

  case 'CLOSED':
    executeClosed();
    break;
}</pre><p>然而， Dart 支持空 <code class="literal">case</code> 块，空快可以允许执行后面一个 case 块的功能：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>var command = 'CLOSED';
switch (command) {
  case 'CLOSED':     // 空块会漏到下个块执行
  case 'NOW_CLOSED':
    //  CLOSED 和 NOW_CLOSED 都会执行该代码
    executeNowClosed();
    break;
}</pre><p>如果你真的需要执行下一个 case 块中的代码，则可以用一个  <code class="literal">continue</code> 语句和一个 label 组合：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>var command = 'CLOSED';
switch (command) {
  case 'CLOSED':
    executeClosed();
    continue nowClosed; // 继续执行 nowClosed label

nowClosed:
  case 'NOW_CLOSED':
    // CLOSED 和 NOW_CLOSED 都会执行该代码
    executeNowClosed();
    break;
}</pre><p> <code class="literal">case</code> 块可以有本地变量，
          该变量只在该 case 块中可见。</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="assert"></a>Assert（断言）</h3></div></div></div><p>使用 <code class="literal">assert</code> 
      语句来检测执行条件，如果提供的条件是 false 则中断执行并抛出异常。下面是一个
      assert 示例：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>assert(text != null);  // 确保 text 不为 null
assert(number &lt; 100);  // 确保该值小于 100.
assert(urlString.startsWith('https')); // 确保字符串以 https 开头</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Assert 语句只在检测模式下有效。
            在生产模式下无任何效果。</p></div><p> <code class="literal">assert</code> 的参数可以是任何结果为 布尔 值的表达式或者方法。
      如果表达式或者方法的返回值为 true， 则通过断言检测代码继续执行。否则，断言将抛出一个异常  (是一个 <a class="ulink" href="http://api.dartlang.org/dart_core/AssertionError.html" target="_top">AssertionError</a>)。
      </p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="exceptions"></a>Exceptions（异常）</h2></div></div></div><p>
        Dart 代码可以抛出和捕获异常。异常代表不可预期的错误情况。如果没有捕获异常，
        则抛出该异常的 isolate 将被挂起，通常该 isolate 就退出执行了。</p><p>和 Java 语言不同， Dart 的所有异常都是 非检查异常（unchecked exceptions）。
        函数不用声明其可能抛出的异常，并且你也无捕获任何 <span class="keep-together">exceptions（异常）</span>。</p><p>Dart 提供了 <a class="ulink" href="http://api.dartlang.org/dart_core/Exception.html" target="_top">Exception</a>
    和 <a class="ulink" href="http://api.dartlang.org/docs/continuous/dart_core/Error.html" target="_top">Error</a>
    类型，和很多预定义的子类。你也可以定义自己的异常类型。
    然而，Dart 程序可以把任意非 null 对象当做异常抛出，而不仅仅是  Exception 和 Error 对象。</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="ch02-exceptions-throw"></a>Throw</h3></div></div></div><p>下面是 <span class="emphasis"><em>抛出</em></span> 异常的示例：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>throw new ExpectException('Value must be greater than zero');</pre><p>还可以抛出其他任意对象：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>throw 'Out of llamas!';</pre><p>
          由于抛出异常是一个表达式，所有在任意可以用表达式的地方都可以抛出异常，
          例如  =&gt; 语句。</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>distanceTo(Point other) =&gt; throw new UnimplementedError();</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="ch02-exceptions-catch"></a>Catch</h3></div></div></div><p>捕获异常可以阻止异常继续传递下去。捕获异常提供了一个处理该异常的机会：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>try {
  breedMoreLlamas();
} on OutOfLlamasException {
  buyMoreLlamas();
}</pre><p>
          要处理可能抛出多个类型异常的情况，你可以用多个
          catch 语句。 如果第一个 catch 语句不匹配该异常，则执行下一个。
          如果一个 catch 语句没有设置特殊的异常类型，则该 catch 语句可以处理
          所有 类型的异常：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>try {
  breedMoreLlamas();
} on OutOfLlamasException {           // 一个具体的异常
  buyMoreLlamas();
} on Exception catch(e) {             // 任意 Exception 异常
  print('Unknown exception: $e');
} catch(e) {                          // 处理所有异常
  print('Something really unknown: $e');
}</pre><p>
          如上代码所示， 你可以用
           <code class="literal">on</code> 或者 <code class="literal">catch</code>
      ，也可以同时使用。当需要指定异常类型的时候，用 <code class="literal">on</code>。
      当需要使用 异常 对象的时候，用  <code class="literal">catch</code>
	。      </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="ch02-exceptions-finally"></a>Finally</h3></div></div></div><p>
           <code class="literal">finally</code> 块中的代码不管是否出现异常
           都会执行。如果没有 <code class="literal">catch</code> 捕获异常，则异常会在执行
           完 <code class="literal">finally</code> 块之后继续传递下去：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>try {
  breedMoreLlamas();
} finally {
  cleanLlamaStalls();  // 总是清理现场，不管是否抛出异常
}</pre><p><code class="literal">finally</code> 块在
      <code class="literal">catch</code> 块之后执行：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>try {
  breedMoreLlamas();
} catch(e) {
  print('Error: $e');  // 先处理异常
} finally {
  cleanLlamaStalls();  // 再执行清理
}</pre><p>更多信息请参考 <a class="xref" href="ch03.html#ch03-exceptions" title="异常（Exceptions）">the section called “异常（Exceptions）”</a>。</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="classes"></a>Classes</h2></div></div></div><p>Dart 是面向对象的语言，支持 类和单继承。
        每个对象都是一个类的实例，所有的类都是 
    <a class="ulink" href="http://api.dartlang.org/dart_core/Object.html" target="_top">Object</a> 的子类。</p><p>可以用 <code class="literal">new</code> 关键字和 类的
    <em class="firstterm">构造函数</em> 创建对象。
    构造函数的名字可以为
      <span class="emphasis"><em><em class="replaceable"><code>ClassName</code></em></em></span> 或者
    <em class="replaceable"><code>ClassName.identifier</code></em>。例如：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>var jsonData = JSON.decode('{"x":1, "y":2}');

var p1 = new Point(2,2);               // 用 Point() 创建一个 Point 对象。
var p2 = new Point.fromJson(jsonData); // 用 Point.fromJson() 构造函数创建 Point 对象</pre><p>对象有<em class="firstterm">成员变量</em> 构成的数据和方法 (<em class="firstterm">函数</em> 和 <em class="firstterm"> 
    实例变量</em> )。 当调用一个函数的时候，
    该函数可以访问对象的数据：</p><p>使用一个圆点 (.) 来访问对象的变量或者函数：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>var p = new Point(2,2);

p.y = 3;             // 设置实例变量 y 的值
assert(p.y == 3);    // 访问实例变量 y 的值

num distance = p.distanceTo(new Point(4,4)); // 调用 p 的 distanceTo() 函数</pre><p>当想在同一个对象上执行多个操作的时候，可以用级联操作符  (..) ：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>querySelector('#button')
    ..text = 'Click to Confirm'                        // Get an object. Use its
    ..classes.add('important')                         // instance variables
    ..onClick.listen((e) =&gt; window.alert('Confirmed!')); // and methods.</pre><p>
        有些类提供了常量构造函数。可以用来创建编译期常量对象，用
         <code class="literal">const</code> 关键字而不是  <code class="literal">new</code> 来调用这种构造函数：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>var p = const ImmutablePoint(2,2);</pre><p>用常量构造函数创建两个一样的常量，这两个
        常量是 同一个 <span class="keep-together">实例：</span></p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>var a = const ImmutablePoint(1, 1);
var b = const ImmutablePoint(1, 1);

assert(identical(a,b)); // 同一个实例！</pre><p>下面的小节介绍如何定义类</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="ch02-instance-variables"></a>实例变量</h3></div></div></div><p>下面是定义实例变量的示例：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em><em><span class="remark">ch02/instance_variables.dart
</span></em>class Point {
  num x;      // 定义一个实例变量 (x)，初始值为 null。
  num y;      // 定义 y， 初始值为  null。
  num z = 0;  // 定义 z， 初始值为 0。
}</pre><p>所有没有初始化的实例变量的值都是 <code class="literal">null</code>。</p><p>
          所有实例变量都自动生成一个隐含的
      <em class="firstterm">getter</em> 函数。非 final 实例变量也生成了一个隐含的
      <em class="firstterm">setter</em> 函数。详情请参考
        <a class="xref" href="ch02.html#classes-getters-and-setters" title="Getters 和 setters">the section called “Getters 和 setters”</a>。</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em><em><span class="remark">ch02/instance_variables.dart
</span></em>class Point {
  num x;
  num y;
}

main() {
  var point = new Point();
  point.x = 4;             // 调用 x 的 setter 函数
  assert(point.x == 4);    // 调用 x 的 getter 函数
  assert(point.y == null); // 默认值为 null。
}</pre><p>
          如果你在定义实例变量的时候就设置她的值，而不是在构造函数或者其他函数中设置，则该实例创建的时候赋值变量的值。
	赋值操作发生在构造函数和初始化列表执行之前。</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="ch02-constructors"></a>构造函数</h3></div></div></div><p>
          构造函数的名字和类的名字一样（还可以附加其他关键字，<a class="xref" href="ch02.html#ch02-constructors-named" title="命名构造函数">the section called “命名构造函数”</a>）。
          常用的构造函数就是用来创建一个类的实例的：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em><em><span class="remark">ch02/constructor_long_way.dart
</span></em>class Point {
  num x;
  num y;

  Point(num x, num y) {
    // 这种初始化赋值操作还有更好的实现方式，请往下看！
    this.x = x;
    this.y = y;
  }
}</pre><p>  <code class="literal">this</code> 关键字引用当前实例。</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>只有在有名字冲突的时候才使用 <code class="literal">this</code> 。
            其他情况， Dart 风格指南建议忽略
             <code class="literal">this</code>。</p></div><p>
          把构造函数参数赋值给实例变量是如此的常见，所以 Dart 提供了一个语法糖让该操作更加便捷：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>class Point {
  num x;
  num y;

  // 在构造函数体执行之前设置实例变量的语法糖
  Point(this.x, this.y);
}</pre><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="ch02-constructors-default"></a>默认构造函数</h4></div></div></div><p>如果没有定义构造函数，则会生成一个默认构造函数。
            默认构造函数没有参数，并调用没有参数的 <span class="keep-together">superclass（父类）</span> 构造函数。</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="ch02-constructors-not-inherited"></a>构造函数不支持继承</h4></div></div></div><p>
            子类并没有继承父类的构造函数。
            一个没有定义构造函数的子类只有无参数无名子的默认构造函数。</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="ch02-constructors-named"></a>命名构造函数</h4></div></div></div><p>
            用命名构造函数来提供多个构造函数或者提供更加清晰的信息：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em><em><span class="remark">ch02/named_constructor.dart
</span></em>class Point {
  num x;
  num y;

  Point(this.x, this.y);

  // 命名构造函数
  Point.fromJson(Map json) {
    x = json['x'];
    y = json['y'];
  }
}</pre><p>
            注意：构造函数不支持继承，所以子类也没有继承父类的命名构造函数。
            如果你想让子类也能用父类的命名构造函数，则你必需在子类中定义并实现该构造函数。</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="ch02-constructor-non-default-superclass"></a>调用不是默认的父类构造函数</h4></div></div></div><p>
            默认情况下，子类的构造函数会调用父类的默认构造函数。
            如果父类没有无名无参数的默认构造函数，则子类必需
            手工的调用一个父类构造函数。
           在冒号
        (<code class="literal">:</code>) 后面和构造函数体之前指定要调用的父类构造函数。</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em><em><span class="remark">ch02/op_as.dart
</span></em>class Person {
  Person.fromJson(Map data) {
    print('in Person');
  }
}

class Employee extends Person {
  // Person 没有默认构造函数
  // 所以必需指定 super.fromJson(data) 构造函数
  Employee.fromJson(Map data) : super.fromJson(data) {
    print('in Employee');
  }
}

main() {
  var emp = new Employee.fromJson({});

  // 打印结果：
  // in Person
  // in Employee
}</pre><p>
            由于调用父类构造函数的参数在执行构造函数之前执行，
            所有可以用表达式作为参数，例如 用一个方法：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em><em><span class="remark">ch02/method_then_constructor.dart
</span></em>class Employee extends Person {
  ...
  Employee() : super.fromJson(findDefaultData());
}</pre><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>
              调用父类构造函数的参数无法访问 
          <code class="literal">this</code> 对象。
          例如，参数可以访问静态函数当时无法访问实例函数。</p></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="ch02-constructor-initializer-list"></a>初始化列表</h4></div></div></div><p>
            除了调用父类构造函数外，也可以在执行构造函数体之前来初始化实例变量。
            用逗号分割多少初始化变量。</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em><em><span class="remark">ch02/initializer_list.dart
</span></em>class Point {
  num x;
  num y;

  Point(this.x, this.y);

  // 初始化列表在构造函数体执行之前设置实例变量
  Point.fromJson(Map json) : x = json['x'], y = json['y'] {
    print('In Point.fromJson(): ($x, $y)');
  }
}</pre><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p> 右边的初始化列表无法访问 
          <code class="literal">this</code>.</p></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="ch02-constructor-redirecting"></a>重定向构造函数</h4></div></div></div><p>有些构造函数只是调用
         <span class="keep-together">同一个类</span> 的另外一个构造函数。
         重定向构造函数体是空的，被调用的构造函数放到冒号后面。</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em><em><span class="remark">ch02/along_x_axis.dart
</span></em>class Point {
  num x;
  num y;

  Point(this.x, this.y);                // 该类的主要构造函数
  Point.alongXAxis(num x) : this(x, 0); // 调用主要构造函数
}</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="ch02-constructor-constant"></a>常量构造函数</h4></div></div></div><p>
            如果你的类生成从来不改变的对象，则可以把这些对象定义为编译期常量。
            用一个 <code class="literal">const</code> 
        构造函数并把实例变量设置为  <code class="literal">final</code> 来实现该功能。</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em><em><span class="remark">ch02/immutable_point.dart
</span></em>class ImmutablePoint {
  final num x;
  final num y;
  const ImmutablePoint(this.x, this.y);
  static final ImmutablePoint origin = const ImmutablePoint(0, 0);
}</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="ch02-constructor-factory"></a>工厂构造函数</h4></div></div></div><p>如果一个构造函数并不总是创建一个新的对象，则可以用
            <code class="literal">factory</code> 关键字来实现构造函数。
            例如，一个工厂构造函数可以从缓存中返回一个实例，也可以返回一个子类型的实例。</p><p>下面演示了从缓存返回实例的工厂构造函数：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em><em><span class="remark">ch02/factory_constructor.dart
</span></em>class Logger {
  final String name;
  bool mute = false;

  // _cache is library-private, thanks to the _ in front of its name.
  static final Map&lt;String, Logger&gt; _cache = &lt;String, Logger&gt;{};
  
  factory Logger(String name) {
    if (_cache.containsKey(name)) {
      return _cache[name];
    } else {
      final logger = new Logger._internal(name);
      _cache[name] = logger;
      return logger;
    }
  }
  
  Logger._internal(this.name);
  
  void log(String msg) {
    if (!mute) {
      print(msg);
    }
  }
}</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>工厂构造函数无法访问  <code class="literal">this</code>。</p></div><p>用 <code class="literal">new</code> 关键字调用工厂构造函数：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em><em><span class="remark">ch02/factory_constructor.dart
</span></em>var logger = new Logger('UI');
logger.log('Button clicked');</pre></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="ch02-methods"></a>函数</h3></div></div></div><p>
          函数定义了一个对象的行为。</p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="ch02-methods-instance"></a>实例函数</h4></div></div></div><p>对象的实例函数可以访问实例变量和 
        <code class="literal">this</code>。
        下面示例的 
        <code class="literal">distanceTo()</code> 函数就是一个
        实例函数：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em><em><span class="remark">ch02/distance_to.dart
</span></em>import 'dart:math';

class Point {
  num x;
  num y;
  Point(this.x, this.y);

  num distanceTo(Point other) {
    var dx = x - other.x;
    var dy = y - other.y;
    return sqrt(dx * dx + dy * dy);
  }
}</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="classes-getters-and-setters"></a>Getters 和 setters</h4></div></div></div><p>Getters 和 setters 
            是特殊的用来设置和访问实例变量的函数。
            每个实例变量都有一个隐含的 getter，非 final 变量还有一个 setter 函数。
            通过显式的实现 getter 和 setter 可以附件额外的功能。
            用
        <code class="literal">get</code> 和 <code class="literal">set</code> 关键字实现 getter 和 setter：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em><em><span class="remark">ch02/rectangle.dart
</span></em>class Rectangle {
  num left;
  num top;
  num width;
  num height;

  Rectangle(this.left, this.top, this.width, this.height);

  // 定义两个计算出来的属性：right 和 bottom.
  num get right             =&gt; left + width;
      set right(num value)  =&gt; left = value - width;
  num get bottom            =&gt; top + height;
      set bottom(num value) =&gt; top = value - height;
}

main() {
  var rect = new Rectangle(3, 4, 20, 15);
  assert(rect.left == 3);
  rect.right = 12;
  assert(rect.left == -8);
}</pre><p>有了 getters 和 setters，你可以先直接用实例变量，
            当发现需要添加额外操作了再用 getter 和 setter 包起来，
            这样调用代码无需做任何修改。</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                对于 ++ 这种操作符而言，不管是否显式定义 getter 情况都有点特殊。
                为了避免其他副作用，操作符只调用一次 getter 并缓存该返回值。</p></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="ch02-method-abstract"></a>抽象函数</h4></div></div></div><p>实例函数、 getter、 和 setter 都可以为抽象函数，
            只定义接口，由子类来实现该函数。
            用分号
           (;) 结尾 没有函数体的函数就是抽象函数：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em><em><span class="remark">ch02/doer.dart
</span></em>abstract class Doer {
  // ...Define instance variables and methods...
 
  void doSomething(); // 定义一个抽象函数
}

class EffectiveDoer extends Doer {
  void doSomething() {
    // ...Provide an implementation, so the method is not abstract here...
  }
}</pre><p>调用一个抽象函数在运行的时候会出现异常。</p><p>参考 <a class="xref" href="ch02.html#ch02-class-abstract" title="抽象类">the section called “抽象类”</a>。</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="classes-operators"></a>重写操作符</h4></div></div></div><p>可以重新  <a class="xref" href="ch02.html#overridden_operator_table" title="Table 2.11. 可被重写的操作符">Table 2.11, “可被重写的操作符”</a> 表中的操作符。例如，
        如果你定义一个
        Vector 类，则可以重写 <code class="literal">+</code> 函数来实现 vector 相加操作。</p><div class="table"><a name="overridden_operator_table"></a><p class="title"><b>Table 2.11. 可被重写的操作符</b></p><div class="table-contents"><table summary="可被重写的操作符" border="1"><colgroup><col><col><col><col></colgroup><tbody><tr><td>&lt;</td><td>+</td><td>|</td><td>[]</td></tr><tr><td>&gt;</td><td>/</td><td>^</td><td>[]=</td></tr><tr><td>&lt;=</td><td>~/</td><td>&amp;</td><td>~</td></tr><tr><td>&gt;=</td><td>*</td><td>&lt;&lt;</td><td>==</td></tr><tr><td>–</td><td>%</td><td>&gt;&gt;</td><td class="auto-generated"> </td></tr></tbody></table></div></div><br class="table-break"><p>下面是一个重写  <code class="literal">+</code> 和 <code class="literal">-</code>
        操作符的示例：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em><em><span class="remark">ch02/vector.dart
</span></em>class Vector {
  final int x;
  final int y;
  const Vector(this.x, this.y);

  Vector operator +(Vector v) { // Overrides + (a + b).
    return new Vector(x + v.x, y + v.y);
  }

  Vector operator -(Vector v) { // Overrides - (a - b).
    return new Vector(x - v.x, y - v.y);
  }
}

main() {
  final v = new Vector(2,3);
  final w = new Vector(2,2);

  assert(v.x == 2 &amp;&amp; v.y == 3);         // v   == (2,3)
  assert((v+w).x == 4 &amp;&amp; (v+w).y == 5); // v+w == (4,5)
  assert((v-w).x == 0 &amp;&amp; (v-w).y == 1); // v-w == (0,1)
}</pre><p>重写  <code class="literal">==</code> 的示例在  <a class="xref" href="ch03.html#ch03-implementing-map-keys" title="实现 map 的 key">the section called “实现 map 的 key”</a> 有介绍。
        关于重写的更多信息，参考 <a class="xref" href="ch02.html#ch02-class-extend" title="继承一个类">the section called “继承一个类”</a>。</p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="ch02-class-abstract"></a>抽象类</h3></div></div></div><p>使用 <code class="literal">abstract</code>
          修饰符来定义一个  <em class="firstterm">抽象类</em>，抽象类无法被实例化。
          抽象类通常用于定义接口并具有一些基本行为实现。如果你想让你的抽象类看起来是可被实例化的，则可以提供一个
      <a class="link" href="ch02.html#ch02-constructor-factory" title="工厂构造函数">工厂构造函数</a>。</p><p>抽象类一般都有 <a class="link" href="ch02.html#ch02-method-abstract" title="抽象函数">抽象函数</a>。
      下面是一个定义抽象类和抽象方法的示例：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em><em><span class="remark">ch02/abstract.dart
</span></em>// 该类为 abstract 的，所以无法实例化
abstract class AbstractContainer {
  // ...Define constructors, fields, methods...

  void updateChildren(); // 抽象函数
}</pre><p>下面的类虽然有抽象函数，但是并不是抽象类，所以可以实例化：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em><em><span class="remark">ch02/abstract.dart
</span></em>class SpecializedContainer extends AbstractContainer {
  // ...Define more constructors, fields, methods...

  void updateChildren() {
    // ...Implement updateChildren()...
  }
// Abstract method causes a warning but doesn't prevent instantiatation.
  void doSomething(); 
}</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="ch02-implicit-interfaces"></a>隐式接口（Implicit Interfaces）</h3></div></div></div><p>
          每个类都隐式的定义了一个包含所有实例变量和所实现所有接口的接口。
          如果你想创建一个类 A 支持 类 B 的 API，但是又不想继承类 B 的实现，则类 A 可以实现
          类 B 的隐式接口。</p><p>
          类通过
      <code class="literal">implements</code> 语句来定义其实现的其他类的接口，
      并实现需要的 API。 例如：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em><em><span class="remark">ch02/imposter.dart
</span></em>// 一个  person 类， 隐式接口包含  greet().
class Person {
  final _name;          // 该变量在隐式接口中，但是是库返回可见的
  Person(this._name);   // 这是个构造函数，不在隐式接口中
  String greet(who) =&gt; 'Hello, $who. I am $_name.'; // 在隐式接口中
}

// 实现 Person 的隐式接口。
class Imposter implements Person {
  final _name = "";      // We have to define this, but we don't use it.
  String greet(who) =&gt; 'Hi $who. Do you know who I am?';
}

greetBob(Person person) =&gt; person.greet('bob');

main() {
  print(greetBob(new Person('kathy')));
  print(greetBob(new Imposter()));
}</pre><p>下面是实现多个接口的示例：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em><em><span class="remark">ch02/point_interfaces.dart
</span></em>class Point <span class="bold"><strong>implements Comparable, Location</strong></span> {
  // ...
}</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="ch02-class-extend"></a>继承一个类</h3></div></div></div><p>用 <code class="literal">extends</code> 
      来继承类，在子类中用 <code class="literal">super</code> 
      访问父类：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em><em><span class="remark">smart_tv.dart
</span></em>class Television {
  void turnOn() {
    _illuminateDisplay();
    _activateIrSensor();
  }
  ...
}

class SmartTelevision extends Television {
  void turnOn() {
    super.turnOn();
    _bootNetworkInterface();
    _initializeMemory();
    _upgradeApps();
  }
  ...
}</pre><p>
          子类可以重写实例函数、getter 、和 setter。
          下面是一个重写 Object 类
      <code class="literal">noSuchMethod()</code> 函数的示例，该函数在
      调用一个不存在的函数或者实例变量时触发：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em><em><span class="remark">ch02/no_such_method.dart
</span></em>class A {
  // Unless you override noSuchMethod, using a non-existent member
  // results in a NoSuchMethodError.
  void noSuchMethod(Invocation mirror) {
    print('You tried to use a non-existent member: ${mirror.memberName}');
  }
}</pre><p>可以用 <code class="literal">@override</code> 注解来表明你需要
          重写该函数或者变量：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em><em><span class="remark">ch02/ch02_meta/bin/ch02_override.dart
</span></em>class A {
  @override
  void noSuchMethod(Invocation mirror) {
    // ...
  }
}</pre><p>如果用 <code class="literal">noSuchMethod()</code> 实现了所有可能的
        getter、 setter、 和一个类的函数，则可以用
      <code class="literal">@proxy</code> 注解来避免警告信息：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em><em><span class="remark">ch02/ch02_meta/bin/ch02_proxy.dart
</span></em>@proxy
class A {
  void noSuchMethod(Invocation mirror) {
    // ...
  }
}</pre><p>关于注解的详细信息，参考 <a class="xref" href="ch02.html#ch02-metadata" title="Metadata（元数据）">the section called “Metadata（元数据）”</a>。</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="ch02-mixins"></a>在类中添加功能： Mixins（混入）</h3></div></div></div><p>Mixins 是一种不用继承就可以在一个类中
          添加功能的方法。</p><p>用  <code class="literal">with</code> 关键字后跟
          一个或者多个 mixin 名字来实现 mixin。
     下面的代码演示了 mixin 的两个示例：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em><em><span class="remark">ch02/mixins.dart
</span></em>class Musician extends Performer with Musical {
  ...
}

class Maestro extends Person with Musical, Aggressive, Demented {
  Maestro(String maestroName) {
    name = maestroName;
    canConduct = true;
  }
}</pre><p>
          如何创建 mixin：定义一个继承 Object 的类，不定义构造函数也不调用
          <code class="literal">super</code> 即可。例如：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em><em><span class="remark">ch02/mixins.dart
</span></em>abstract class Musical {
  bool canPlayPiano = false;
  bool canCompose = false;
  bool canConduct = false;
  
  void entertainMe() {
    if (canPlayPiano) {
      print('Playing piano');
    } else if (canConduct) {
      print('Waving hands');
    } else {
      print('Humming to self');
    }
  }
}</pre><p>详细信息请参考  <a class="ulink" href="http://www.dartlang.cc/articles/mixins/" target="_top">Mixins in
      Dart</a> 文章。</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="ch02-class-vars-and-methods"></a>类（静态）变量和函数</h3></div></div></div><p>用 <code class="literal">static</code> 关键字实现类
          变量和函数。</p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="ch02-static-variables"></a>静态变量</h4></div></div></div><p>静态变量 (类变量) 用于类范围的状态和常量：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em><em><span class="remark">ch02/color.dart
</span></em>class Color {
  static const RED = const Color('red'); // 一个静态常量
  final String name;                     // 一个实例变量
  const Color(this.name);                // 一个常量构造函数
}

main() {
  assert(Color.RED.name == 'red');
}</pre><p>静态变量在使用的时候才初始化。</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="ch02-static-methods"></a>静态函数</h4></div></div></div><p>静态函数 (类函数) 没有在实例上操作，也无法访问
         <code class="literal">this</code>。例如：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em><em><span class="remark">ch02/point.dart
</span></em>import 'dart:math';

class Point {
  num x;
  num y;
  Point(this.x, this.y);

  static num distanceBetween(Point a, Point b) {
    var dx = a.x - b.x;
    var dy = a.y - b.y;
    return sqrt(dx * dx + dy * dy);
  }
}

main() {
  var a = new Point(2, 2);
  var b = new Point(4, 4);
  var distance = Point.distanceBetween(a,b);
  assert(distance &lt; 2.9 &amp;&amp; distance &gt; 2.8);
}</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
              对于常用的工具类函数，可以用顶级函数来替代静态函数。</p></div><p>
            可以把静态函数当做编译期常量。
            例如，你可以把静态函数当做参数传递给常量构造函数。</p></div></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="generics"></a>Generics（泛型）</h2></div></div></div><p>如果你查看 
    <a class="ulink" href="http://api.dartlang.org/dart_core/List.html" target="_top">List </a>
    的 API 文档，你会发现其类型定义为
    <code class="literal">List&lt;E&gt;</code>。  &lt;...&gt; 说明
    List 是一个 <span class="emphasis"><em>generic（泛型）</em></span> (或者
    <span class="emphasis"><em>parameterized（可参数化的）</em></span>) 类型 。
    习惯上用一个字母来表达类型定义，例如  E、 T、 S、 K、和 V。</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="ch02-generics-why"></a>为何使用泛型？</h3></div></div></div><p>
          由于 Dart 的类型是可选的，所以你可以从来不用泛型。
          泛型可以帮助你注释你的代码，让你的意图表达的更清晰。</p><p>例如，如果你想让一个 list 里面只包含 string，
          你可以通过  <code class="literal">List&lt;String&gt;</code>
      (读作 <span class="quote">“<span class="quote">string 类型的列表 </span>”</span>) 来表达你的意图。
      这样，你的同事或者 IDE 以及运行在检测模式下的 Dart VM 可以检测是否保存该
      list 中的对象为 string。如果不是，则会提醒你可能出错了。
      下面是一个示例：</p><pre class="programlisting"><em><span class="remark">lang-dart</span></em><em><span class="remark">
ch02/generics.dart
</span></em>var names = new List&lt;String&gt;();
names.addAll(['Seth', 'Kathy', 'Lars']);
// ...
names.add(42); // 在检测模式会出错 (生产模式可以运行).</pre><p>
          另外用泛型也可以减少重复代码。
          泛型可以让你实现在多个类型之间公用的操作，
          同时还没丧失代码静态分析和检测模式提醒的优势。
          例如，你想创建一个缓存对象的接口：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>abstract class ObjectCache {
  Object getByKey(String key);
  setByKey(String key, Object value);
}</pre><p>后来你又需要一个 String 类型的缓存，所以你又创建一个：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>abstract class StringCache {
  String getByKey(String key);
  setByKey(String key, String value);
}</pre><p>后来，你又需要一个其他类型的缓存，所以你想到一个办法。</p><p>
          泛型可以完美的解决该问题。</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>abstract class Cache&lt;T&gt; {
  T getByKey(String key);
  setByKey(String key, T value);
}</pre><p>
          在上面的代码中，T 是一个占位符类型。 
          你可以认为这是一个调用者在使用的时候会设置的类型。</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="generics-literals"></a>使用集合字面量</h3></div></div></div><p>List 和 map 的字面量定义也可以泛型化。
          只需要在字面量前面添加一个 
      <code class="literal">&lt;<em class="replaceable"><code>泛型类型</code></em>&gt;</code> (
      用于 lists ) 或者 <code class="literal">&lt;<em class="replaceable"><code>keyType</code></em>,
      <em class="replaceable"><code>valueType</code></em>&gt;</code> (用于 maps) 即可。
      如果你想在检测模式使用类型警告提示，则可以使用泛型字面量来定义集合。
      下面是一个示例：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>var names = &lt;String&gt;['Seth', 'Kathy', 'Lars'];
var pages = &lt;String, String&gt;{
    'index.html':'Homepage',
    'robots.txt':'Hints for web robots',
    'humans.txt':'We are people, not machines' };</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="generics-constructors"></a>使用泛型构造函数</h3></div></div></div><p>
          在构造函数类名后面放一个尖括号和类型（<code class="literal">&lt;...&gt;</code>）
          可以使用泛型构造函数。例如：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>var names = new List&lt;String&gt;();
names.addAll(['Seth', 'Kathy', 'Lars']);
var nameSet = new Set&lt;String&gt;.from(names);</pre><p>下面的代码创建了一个 key 为 int，value 为 View 对象的 map：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>var views = new Map&lt;int, View&gt;();</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="generics-collections"></a>泛型集合和类型</h3></div></div></div><p>Dart 的泛型类型被 <span class="emphasis"><em>固化了</em></span>，
          这表明在运行时也带有类型信息。
          例如，你可以在生产模式下测试集合类型：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>var names = new List&lt;String&gt;();
names.addAll(['Seth', 'Kathy', 'Lars']);
print(names is List&lt;String&gt;); // true</pre><p><code class="literal">is</code> 表达式只检查
       <span class="emphasis"><em>集合</em></span> 的类型而不检查里面的对象类型。
       在生产模式下，一个
      <code class="literal">List&lt;String&gt;</code> 集合可能包含非 stirng 对象。
      可以通过检查每个集合里面的对象类型或者在一个异常处理器中处理每个集合元素
      (参考 <a class="xref" href="ch02.html#exceptions" title="Exceptions（异常）">the section called “Exceptions（异常）”</a>)。</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>和 Java 不同， Java 中的泛型信息被 <span class="emphasis"><em>清除了</em></span>，
            所以在运行时是没有类型参数的。
            在 Java 中 你可以测试一个 对象是否为 List，但是没法测试一个对象是否为
         <code class="literal">List&lt;String&gt;</code>。</p></div><p>关于泛型的更多信息，请参考 <a class="ulink" href="http://www.dartlang.cc/articles/optional-types/" target="_top">Optional Types in
      Dart</a> 文章。</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="libraries"></a>库和可见性</h2></div></div></div><p>使用 <code class="literal">import</code>、 <code class="literal">part</code>、 和 <code class="literal">library</code> 指令可以帮助创建模块化和可共享的代码库。
    库不仅仅只包含 API，还包含可见性：以下划线(_)开头的标识符只能在库内访问。
     <span class="emphasis"><em>每一个 Dart 应用都是一个库</em></span>。</p><p>库可以用 package（包） 来发布。参考  <a class="xref" href="ch04-tools-pub.html" title="pub: Dart 包管理器">the section called “pub: Dart 包管理器”</a> 了解  pub 的信息。</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="libraries-import"></a>使用库</h3></div></div></div><p>用 <code class="literal">import</code> 
      来定义一个库的命名空间并使用一个库。    
      </p><p>例如， Dart web 应用通常都使用  <a class="ulink" href="http://api.dartlang.org/html.html" target="_top">dart:html</a> 库，可以这样导入该库：
      </p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em><em><span class="remark">ch02/libraries/using_libraries.dart
</span></em>import 'dart:html';</pre><p>  <code class="literal">import</code> 必需的一个参数为库的  URI<a href="#ftn.ch02-footnote-1" class="footnote" name="ch02-footnote-1"><sup class="footnote">[1]</sup></a>。对于 内置的库， URI 用
      特殊的 <code class="literal">dart:</code> 协议。
      其他库，可以用文件路径或者
       <code class="literal">package:</code> 协议。 <code class="literal">package:</code> 
      协议的库由包管理器管理，例如 pub 工具。示例：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em><em><span class="remark">ch02/libraries/using_schemes.dart, mylib, utils
</span></em>import 'dart:io';
import 'package:mylib/mylib.dart';
import 'package:utils/utils.dart';</pre><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="libraries-prefix"></a>设置库的前缀</h4></div></div></div><p>
            如果两个库具有同样的标识符，则会出现命名冲突，可以用库前缀解决命名冲突。
        </p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em><em><span class="remark">ch02/libraries/library_prefix.dart, lib1, lib2
</span></em>import 'package:lib1/lib1.dart';
import 'package:lib2/lib2.dart' as lib2;
// ...
var element1 = new Element();      // 用 lib1 的 Element
var element2 = new lib2.Element(); // 用 lib2 的 Element</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="ch02-library-import-part"></a>只导入库的一部分</h4></div></div></div><p>如果你只使用库的一部分，可以导入只使用的功能。</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em><em><span class="remark">ch02/libraries/library_partil.dart, lib1, lib2
</span></em>import 'package:lib1/lib1.dart' show foo; // Import only foo.
import 'package:lib2/lib2.dart' hide foo; // Import all names EXCEPT foo.</pre></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="libraries-implementing"></a>实现一个库</h3></div></div></div><p>用 <code class="literal">library</code> 指令来命名一个库，
      用 <code class="literal">part</code> 来设置库中的其他文件。</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>在一个应用（包含 顶级 main() 方法的文件 ）中无需用 <code class="literal">library</code> 
            ，但是使用 library 可以在多个文件中实现你的应用。</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="libraries-library"></a>定义一个库</h4></div></div></div><p>用  <code class="literal">library
        <em class="replaceable"><code>标识符</code></em></code> 指定当前库的名字：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em><em><span class="remark">ch02/ballgame.dart
</span></em>library ballgame;   // 定义这是一个名字为 ballgame 的库

import 'dart:html'; // 该应用使用 html 库
// ...Code goes here...
</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="libraries-source"></a>关联库中的文件</h4></div></div></div><p>在往库中添加文件，在带有  <code class="literal">library</code> 指令的文件中用  <code class="literal">part
        <em class="replaceable"><code>fileUri</code></em></code>
        ，
        <span class="emphasis"><em>fileUri</em></span> 是要包含的文件路径。
        然后在该文件的实现中用 
     <code class="literal">part of
        <em class="replaceable"><code>identifier</code></em></code> 语句定义（ <span class="emphasis"><em>identifier</em></span> 是
        库的名字）。
        下面的示例中，用 <code class="literal">part</code> 和 <code class="literal">part
        of</code> 实现一个包含三个文件的库。</p><p>第一个文件  <code class="literal">ballgame.dart</code> 定义了 
        ballgame 库，导入其他需要的库并指定
        <code class="literal">ball.dart</code> 和 <code class="literal">util.dart</code> 文件也属于该库：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em><em><span class="remark">ch02/ballgame.dart
</span></em>library ballgame;

import 'dart:html';
// ...Other imports go here...

part 'ball.dart';
part 'util.dart';

// ...Code might go here...</pre><p>第二个文件  <code class="literal">ball.dart</code> 定义了 part of ballgame 语句，
            并实现了 ballgame 的一部分代码:</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em><em><span class="remark">ch02/ball.dart
</span></em>part of ballgame;

// ...Code goes here...</pre><p>第三个文件 <code class="literal">util.dart</code> 同样
            实现了 ballgame 的其他代码：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em><em><span class="remark">ch02/util.dart
</span></em>part of ballgame;

// ...Code goes here...</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="ch02-library-reexport"></a>重新定义库（export）</h4></div></div></div><p>
            使用从重新定义库功能（export 指令） 可以组合和重新打包库（可以包含所有代码也可以只包含部分代码）。
            例如，你有一个非常大的库，里面包含了一堆小库。或者你想创建一个只包含其他库中一部分功能的库。</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em><em><span class="remark">ch02/french.dart, togo.dart, french_togo.dart
</span></em><span class="emphasis"><em>// In french.dart:</em></span>
library french;
hello() =&gt; print('Bonjour!');
goodbye() =&gt; print('Au Revoir!');

<span class="emphasis"><em>// In togo.dart:</em></span>
library togo;
import 'french.dart';
export 'french.dart' show hello;

<span class="emphasis"><em>// In another .dart file:
</em></span>import 'togo.dart';

void main() {
  hello();   //print bonjour
  goodbye(); //FAIL
}</pre></div></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="isolates"></a>Isolates</h2></div></div></div><p>
        很多流行的浏览器，甚至是移动平台的浏览器，都运行在多核 CPU 上。
        为了使用多核优势，开发者通常都使用共享内存的方式来运行多个线程。
        但是，共享状态并发编程是非常容易出错的，并且导致代码更加复杂。</p><p>而 Dart 的代码都是运行在 
    <span class="emphasis"><em>isolates</em></span> 中而不是线程中。
    每个 isolate 具有自己的内存堆，确保每个 isolate 堆之
    无法共享状态。</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="typedefs"></a>Typedefs</h2></div></div></div><p>在 Dart 中， 方法也是对象。
    用  <span class="emphasis"><em>typedef</em></span> 或者 <span class="emphasis"><em>function-type
    alias</em></span> 可以给一个方法类型设置一个名字，并定义参数和返回值。
    当方法类型赋值到一个变量时， typedef 保留类型信息。</p><p>如下是一个没有用 typedef 的示例：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em><em><span class="remark">ch02/sorted_collection.dart
</span></em>class SortedCollection {
  Function compare;

  SortedCollection(int f(Object a, Object b)) {
    compare = f;
  }
}

int sort(Object a, Object b) =&gt; ... ; // Initial, broken implementation.

main() {
  SortedCollection collection = new SortedCollection(sort);

  // 我们只知道 compare 是一个方法，但是不知道是什么类型的方法
  assert(collection.compare is Function);
}</pre><p>当把 <code class="literal">f</code> 赋值给  <code class="literal">compare</code>
    时类型信息丢失了。
    
     <code class="literal">f</code> 的类型是 <code class="literal">(Object, </code><span class="keep-together"><code class="literal">Object)</code> <span class="unicode">→</span>
    <code class="literal">int</code></span> (这里的 <span class="unicode">→</span> 代表返回值类型)，当然 
     <code class="literal">compare</code> 也是  Function 类型。
    如果用显式的名字和返回值来定义该方法，则开发者和工具都可以使用该信息。</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em><span class="emphasis">typedef int Compare(Object a, Object b);</span>

class SortedCollection {
  Compare compare;

  SortedCollection(this.compare);
}

int sort(Object a, Object b) =&gt; ... ; // Initial, broken implementation.

main() {
  SortedCollection collection = new SortedCollection(sort);
  assert(collection.compare is Function);
  assert(collection.compare is Compare);
}</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
          当前，typedef 只能定义方法类型。
          我们希望能够增强该功能。</p></div><p>由于 typedef 只是简单的别名，并提供了一种检测方法类型的方式。
 例如：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>typedef int Compare(int a, int b);

int sort(int a, int b) =&gt; a - b;

main() {
  assert(sort is Compare);  // True!
}</pre></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ch02-metadata"></a>Metadata（元数据）</h2></div></div></div><p>
        用元数据给你的代码提供额外的信息。元数据注解
        使用 <code class="literal">@</code> 字符开头，后面跟着一个引用合作
        编译期常量（例如 <code class="literal">deprecated</code>）或者调用一个
        常量构造函数。
    </p><p>下面三个注解，所有的 Dart 代码都可以使用：
    <code class="literal">@deprecated</code>、 <code class="literal">@override</code>、 和
    <code class="literal">@proxy</code>。参考
   <a class="xref" href="ch02.html#ch02-class-extend" title="继承一个类">the section called “继承一个类”</a> 查看使用 <code class="literal">@override</code> 和 <code class="literal">@proxy</code>
    的示例。下面是一个使用 
    <code class="literal">@deprecated</code> 注解的示例：</p><pre class="programlisting"><em><span class="remark">lang-dart
ch02/ch02_meta/bin/ch02_meta.dart
</span></em>class Television {
  /// _Deprecated: Use [turnOn] instead._
  @deprecated      // Metadata; makes Dart Editor warn about using activate().
  void activate() {
    turnOn();
  }

  /// Turns the TV's power on.
  void turnOn() {
    print('on!');
  }
}</pre><p>可以定义自己的注解，下面是定义一个带有两个参数的  @todo 注解：</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em><em><span class="remark">ch02/ch02_meta_create/todo.dart
</span></em>library todo;

class todo {
  final String who;
  final String what;
  
  const todo(this.who, this.what);
}</pre><p>下面是使用  @todo 的示例：</p><pre class="programlisting"><em><span class="remark">lang-dart</span></em><em><span class="remark">
ch02/ch02_meta_create/metadata_user.dart
</span></em>import 'todo.dart';

@todo('seth', 'make this do something')
void doSomething() {
  print('do something');
}</pre><p>Metadata 可以出现在 library、 class、 typedef、 type
    parameter、 constructor、factory、 function、 field、 parameter、或者 variable
    declaration 、import 或者 export 之前。 
    以后，可以通过反射来获取元数据信息。
    <em><span class="remark">
    状态跟踪： <a class="ulink" href="https://code.google.com/p/dart/issues/detail?id=6614" target="_top">issue
    #6614</a>。</span></em></p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="comments"></a>注释</h2></div></div></div><p>Dart 支持单行注释、多行注释和文档注释。
        </p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="ch02-comments-single-line"></a>单行注释</h3></div></div></div><p>单行注释以 <code class="literal">//</code> 开头。位于  <code class="literal">//</code> 之后的字符都会被 Dart 编译器
      忽略掉。</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em>main() {
  // TODO: refactor into an AbstractLlamaGreetingFactory?
  print('Welcome to my Llama farm!');
}</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="ch02-comments-multi-line"></a>多行注释</h3></div></div></div><p>多行注释以 <code class="literal">/*</code> 开头，以  <code class="literal">*/</code>结尾。位于 <code class="literal">/*</code> 和 <code class="literal">*/</code>
      之间的 内容被编译器忽略（文档注释除外）。</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em><em><span class="remark">ch02/multi_line_comments.dart
</span></em>main() {
  /*
   * This is a lot of work. Consider raising chickens.

  Llama larry = new Llama();
  larry.feed();
  larry.exercise();
  larry.clean();
   */
}</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="comments-doc"></a>文档注释</h3></div></div></div><p>文档注释是以  <code class="literal">/**</code> 或者 <code class="literal">///</code> 开头的多行或者单行注释。 连续多行使用 <code class="literal">///</code> 和多行文档注释效果一样。</p><p>
          在文档注释中，Dart 编译器只处理位于方括号之间的内容。
          可以用方括号引用 类、函数、变量、顶级变量、方法、和参数。
          方括号内的参数在词法范围内查找代码中对于的标示符。</p><p>下面是一个引用其他类的文档注释。</p><pre class="programlisting"><em><span class="remark">lang-dart
</span></em><em><span class="remark">ch02/doc_comments.dart
</span></em>/**
 * A domesticated South American camelid (Lama glama).
 * 
 * Andean cultures have used llamas as meat and pack animals
 * since pre-Hispanic times.
 */
class Llama {
  String name;

  /**
   * Feeds your llama [Food].
   * 
   * The typical llama eats one bale of hay per week.
   */
  void feed(Food food) {
    // ...
  }

  /// Exercises your llama with an [activity] for
  /// [timeLimit] minutes.
  void exercise(Activity activity, int timeLimit) {
    // ...
  }
}</pre><p>在生成的文档中， <code class="literal">[Food]</code> 变成链接到 
      Food 类 API 文档的超级链接。</p><p>
          可以用 Dart 编辑器来解析 Dart 代码并生成 HTML 文档，编辑器使用的是 SDK 中的 dartdoc 工具。
          生成的文档请参考 <a class="ulink" href="http://api.dartlang.org" target="_top">Dart API 文档</a>。
      关于如何组织注释结构的建议，请参考  <a class="ulink" href="http://www.dartlang.cc/articles/doc-comment-guidelines/" target="_top">Dart 文档注释指南。</a></p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ch02-summary"></a>总结</h2></div></div></div><p>本章总结了 Dart 语言常用的特性。
         为了避免打破现有代码，更多的特性作为 minxin 实现 <a class="ulink" href="http://www.dartlang.cc/articles/mixins/" target="_top">http://www.dartlang.cc/articles/mixins/</a>。详细信息
    参考 <a class="ulink" href="http://www.dartlang.cc/docs/spec/" target="_top">Dart 语言
    规范</a> 和 <a class="ulink" href="http://www.dartlang.cc/articles/" target="_top">相关文章</a> 例如 <a class="ulink" href="http://www.dartlang.cc/articles/idiomatic-dart/" target="_top"> Dart 习惯用法。</a></p></div><div class="footnotes"><br><hr style="width:100; text-align:left;margin-left: 0"><div id="ftn.ch02-footnote-1" class="footnote"><p><a href="#ch02-footnote-1" class="para"><sup class="para">[1] </sup></a>URI 代表 <em class="firstterm">uniform resource
          identifier（统一资源标识符）</em>。 URLs (<em class="firstterm">uniform resource
          locators（统一资源定位符）</em>) 是一种常见的 URI。</p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch01.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ch03.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 1. 快速起步 </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 3. Dart 库概览</td></tr></table></div>
      </article>

      

    </div>
  </div>
</div>  

  <footer class="footer container-full">
    <div class="container">
      <div class="row">
        <div class="col-md-5">
          <h3>一种用于创建可扩展 web 应用程序的语言、工具和代码库</h3>
          <p>Dart 是一个 <a href="https://code.google.com/p/dart/">开源项目</a>，由  Google 和其他人员参与。</p>
          <p class="sm">除非注明，该页面内容使用 the Creative Commons Attribution 3.0 License 发布，示例代码使用  BSD License 发布。</p>
          <!-- 
          <p><a class="saelogo" href="http://sae.sina.com.cn/activity/invite/15649/weibo" target="_blank"><img src="http://static.sae.sina.com.cn/image/poweredby/poweredby.png" title="Powered by Sina App Engine"></a></p>     	
          -->
        </div>
        <div class="col-md-2 col-md-offset-1">
          <h4>受欢迎的文章</h4>
          <ul>
            <li><a href="/polymer-dart/?utm_source=site&amp;utm_medium=footer&amp;utm_campaign=homepage">Polymer.dart</a></li>
            <li><a href="/performance/">性能</a></li>
            <li><a href="/docs/dart-up-and-running/contents/ch02.html?utm_source=site&amp;utm_medium=footer&amp;utm_campaign=homepage">语言概览</a> &amp;
            <a href="/docs/dart-up-and-running/contents/ch03.html?utm_source=site&amp;utm_medium=footer&amp;utm_campaign=homepage">代码库概览</a></li>
            <li><a href="/samples/?utm_source=site&amp;utm_medium=footer&amp;utm_campaign=homepage">示例代码</a></li>
            <li><a href="/docs/tutorials/?utm_source=site&amp;utm_medium=footer&amp;utm_campaign=homepage">教程</a> &amp;
                <a href="/codelabs/darrrt/?utm_source=site&amp;utm_medium=footer&amp;utm_campaign=homepage">代码实验室</a></li>
          </ul>
        </div>
        <div class="col-md-2">
          <h4>资源</h4>
          <ul>
            <li><a href="http://pub.dartlang.org/">Pub packages</a></li>
            <li><a href="http://synonym.dartlang.org/">Translations from Dart</a></li>
            <li><a href="http://code.google.com/p/dart/issues/list">Dart bugs and feature requests</a></li>
          </ul>
        </div>
        <div class="col-md-2">
          <h4>社区</h4>
          <ul>
            <li><a href="/support/">邮件列表</a></li>
            <li><a href="http://bbs.dartlang.cc">中文社区</a></li>
            <li><a href="https://plus.google.com/communities/114566943291919232850">G+ 社区</a></li>
            <li><a href="https://plus.google.com/+dartlang/posts">G+ 新闻发布频道</a></li>
            <li><a href="http://stackoverflow.com/questions/tagged/dart">Stack Overflow</a></li>
          </ul>
        </div>
      </div>
    </div>
  </footer> <!-- End footer -->

<script type='text/javascript' src='/js/jquery.js'></script>
<script type='text/javascript' src='/js/bootstrap.min.js'></script>
<script type='text/javascript' src='/js/prettify.js'></script>
<script type='text/javascript' src='/js/lang-dart.js'></script>
<script type='text/javascript' src='/js/lang-yaml.js'></script>
<script type='text/javascript' src='/js/scripts.js'></script>




<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F76b2695e71e6cec6e6af036d76afa367' type='text/javascript'%3E%3C/script%3E"));
</script>

<!-- Baidu Button BEGIN -->
<script type="text/javascript" id="bdshare_js" data="type=slide&amp;img=1&amp;pos=left&amp;uid=590574" ></script>
<script type="text/javascript" id="bdshell_js"></script>
<script type="text/javascript">
var bds_config={"bdTop":367};
document.getElementById("bdshell_js").src = "http://bdimg.share.baidu.com/static/js/shell_v2.js?cdnversion=" + Math.ceil(new Date()/3600000);
</script>
<!-- Baidu Button END -->
</body>
</html>

